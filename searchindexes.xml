<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>算设 survey：多项式复合能做多快？</title><url>/post/algorithm-design-survey/</url><categories><category>学术</category></categories><tags><tag>学术</tag></tags><content type="html"> 突然诈尸。
挂一下 PDF。英文水平有点差见谅。</content></entry><entry><title>APIO 2024 试机赛 T1 题解</title><url>/post/apio2024-pre-t1-sol/</url><categories><category>题解</category></categories><tags><tag>题解</tag></tags><content type="html"> 反正是试机赛，早点发出来也不要紧，所以就先发出来了。
容易观察到，我们每步总是向右走到可达的最远点。
然而，由于可能单步最优的解在区间外，因此不能直接倍增。
观察到区间最值一定要被选，因此考虑由其分段，变为两个存在一个端点处为最值的子问题。
容易发现这样从最大值开始，下一步必定跳到最小值，再往后必定跳到最大值……以此类推。
考虑如果离线，我们可以对区间的右端点推进扫描线，并维护出当前后缀最大值和最小值位置的单调栈。
这样，我们如果可以快速维护出这些后缀最值之间的树状关系，从而计算出当前节点的深度，即可得到答案。
假设计算时用到的是最大值，则我们只用知道最大值栈到根节点的距离。
考虑最大值栈上相邻两个点。
如果其之间存在数值在前缀最小值上，则答案相差 $2$：需要先转去最小值，再转回最大值；如没有，且两者均在栈顶下面，那么其必定转到同一个最小值上，故答案相同。
可以发现，由于单次操作只会对相邻位置的差值造成贡献，可以用线段树维护。
使用主席树即可在线。
总复杂度 $O(n\log n)$。</content></entry><entry><title>修缮日志</title><url>/post/update-record/</url><categories><category>杂项</category></categories><tags><tag>杂项</tag></tags><content type="html"> 由于 GitHub 博客实在太用起来太复杂了，记录一个修缮日志。
（或者说是踩坑记录）
更新日志想来 GitHub 是会有留存的，不必多说。
2023.9.7 - 9.18
拉了份脚手架搭建起了破烂的博客。
2023.10.10
修了一下文末分割线的锅。
2023.12.12
修了一下博客的结构，把不必要的文件删除了。
手动修改网页源码，把 Font Awesome 更新到了 6.4.0。自带的方法不会用（
把不蒜子统计换成了 https://npm.elemecdn.com/penndu@1.0.0/bsz.js
来加速加载。（来自 https://dusays.com/476/
）
2023.12.13
把 MathJax 又换回了 3（渲染速度快太多了）并重新修了一下渲染方式。
将可能发生问题的行间数学公式部分使用 &amp;lt;div&amp;gt; 标签包裹，行内则采用代码块的方式。
关掉了文首 header 渲染的评论数目（太卡了，完全加载不出来）。</content></entry><entry><title>集训队胡策2023-2024补题记录</title><url>/post/huce2023-record/</url><categories><category>题解</category></categories><tags><tag>题解</tag><tag>做题记录</tag></tags><content type="html"> CTT 结束后发现自己胡策题都没咋补，这下尴尬了。主要原本胡策就打着玩的（
怎么 CTT 平均难度比胡策还要简单啊.jpg。
还是随便写几篇题解吧。
先来个补全进度表，根据胡策 OJ 或 qoj 通过情况来评判：
Problem List 测试赛（10.22） A + B Problem 奥林匹克五子棋 元旦激光炮 Day 1（10.23） 优惠购物 树哈希 网格图最大流计数 Day 2（10.29） 序列 没有创意的题目名称 傅里叶与交通规划 Day 3（11.04） Permutation Counting 2 化学实验 物理实验 Day 4（11.05） 数据库 左蓝右红 世界沉睡童话 Day 5（11.07） Xor Master 栞 数据结构 Day 6（11.09） Grievous Lady Axium Crisis 落日珊瑚 Day 7（11.11） 不是这一道据数构结题 意念力 重排 Day 8（11.12） 基础寄术练习题 【模板】矩阵快速幂 超现实树 Day 9（11.14） 最短路求和 通道建设 Passage Construction Tree Topological Order Counting Day 10（11.16） 雷同 水果茶 茧 Day 11（11.19） 挑战积和式 往日之影 虹 Day 12（11.21） 这不是一道数据结构题 不跳棋 goods Day 13（11.23） 天空度假山庄 建设终末树 童话 Day 14（11.25） 命运 崩坏天际线 Since A Light Day 15（11.26） 括号 染色 coneyisland Day 16（11.28） 最后的晚餐 彩虹航线 积性函数 Day 17（11.30） 棋盘 区间切割 连连看 题解会补的，你先别急。
待更新题解：
Day 1 优惠购物 Day 7 重排 Day 10 雷同 Day 12 这不是一道数据结构题 Day 16 积性函数 Day 7 意念力
题解 考虑链的情况。
容易想到容斥，变成共有 $m$ 种颜色然后给某个节点染色。
我们按链的顺序依次染，每个节点和前若干个不相同，且前若干个也互不相同，容易发现就是形如 $\prod(m-a_j)$，可以直接多点求值或者点值平移。
对于树的情况，我们考虑如何变成和链一样的问题。
结论：我们按照深度顺序 …</content></entry><entry><title>CTT2023游记</title><url>/post/ctt2023/</url><categories><category>游记</category></categories><tags><tag>游记</tag></tags><content type="html"> NOI2023 之后状态一直不咋地，原本要写的 CSP/NOIP 阿克游记也都咕掉了。看看老年退役选手能不能苟进 CTS！
12.1
启程。
9:28 启动的火车，原本我们是 $6$ 个人的：徐老师，zak，sjy，我，cmll，dx。结果徐老师记错日期了没来。
然后就打车去了酒店签到，一到就是先发参赛证书（落款日期还是 12.5）、胸牌和衣服，然后就是登记入住。
今年看上去不是完全随机分寝了，和 sjy 一间。午餐酒店不提供，所以我们去大润发肯德基吃了。
然后后来就是坐大巴去试机，题目还是经典组合（A+B、奥林匹克五子棋、元旦激光炮），前两题直接秒了，T3 又重新推了一遍那个做法。
外接键盘很阴间，又是那款 L 大回车键盘。笔记本 Thinkpad 就是我以前用的款式，用起来还算舒适，所以我就直接抛开外接鼠标、键盘不管了。
晚饭是通常盒饭。
回寝后 sjy 在卷扑克比大小，我直接开摆。
12.2
早起吃早饭，早饭非常丰盛。
然后坐大巴去考场。
开场一看 T1 T2 感觉可以写暴力，T3 题面太长没看。
调了半天 T1 B 性质只有 $\rm0pts$，直到十点多听说数据输出格式有误（行末空格）后绷不住了。
去写 T2，发现自己好像会平方做法。然后敢写敢过。然后赛后一看这就是正解？
回来写 T1，发现稍微改改就是正解，调到 13:00 左右才过。
看 T3，写完 $\rm20pts$ 暴力后发现套个线段树合并好像就可以过了，CTT 就这？不过来不及写所以摆了。
出场后听说 zak 又 $\rm2.5h$ AK 了，总共 AK 了 $13$ 人。有点太猛了。
午饭。
三题出题人分别是左老师、ix35 和注意开。
下午开摆。
晚饭。
晚上开摆。
然后开始毒奶明天考题。
12.3
早起看到 EI 赞了，就感觉不对劲。
拍合照。摄影师：原神！大家：启动！
原神竞赛集训队。
进考场。开题。
？T1 咋还真是构造？
？T2 这是啥？算了先跳过不管。
？T3 咋还真是多项式？还是模 $2^{64}$ 的。
T3 感觉很有头绪！先开 T3！
唰的一下就写了个 $o=1$ 的预处理快速幂上去。
然后看 $o=2$。咋感觉可以转化成 $\bmod2^{63}$，然后迭代成子问题。
写一发。咋被卡常了？松松松。
啪的一下就过了。$\rm440ms$，很快啊！
此时已经是 11:30 了。 …</content></entry><entry><title>uoj514</title><url>/post/uoj514/</url><categories><category>题解</category></categories><tags><tag>题解</tag><tag>uoj</tag></tags><content type="html"><![CDATA[  二维整式递推差不多得咧。
规定 $\Xi:\operatorname{EGF}\rightarrow\operatorname{OGF}$。
考虑令填满后的格子还能继续填，显然答案不变。
那么每步选每个元素的概率均为 $\frac1n$。
我们考虑钦定第一个格子被填满，再枚举最后一步的格子，计算概率，容易发现即为
$$(\Xi(n-1)\frac{z^{b-1}/n^b}{(b-1)!}(\sum_{i\ge a}\frac{(z/n)^i}{i!})(\sum_{i\ge b}\frac{(z/n)^i}{i!})^{n-2})(1)$$
设 $t=z/n$，$u=\exp t$，那么即为
$$(\Xi_z(n-1)\frac{t^{b-1}/n}{(b-1)!}(u-\sum_{i&lt;a}\frac{t^i}{i!})(u-\sum_{i&lt;b}\frac{t^i}{i!})^{n-2})_z(1)$$
从而枚举每个被填满的格子，答案即为
$$(\Xi_z(n-1)\frac{t^{b-1}}{(b-1)!}(u-\sum_{i&lt;a}\frac{t^i}{i!})(u-\sum_{i&lt;b}\frac{t^i}{i!})^{n-2})_z(1)$$
容易知道
$$\Xi_zu^it^j=\frac{j!(z/n)^j}{(1-iz/n)^{j+1}}$$
所以我们只用考虑如何快速计算
$$\frac{t^{b-1}}{(b-1)!}(u-\sum_{i&lt;a}\frac{t^i}{i!})(u-\sum_{i&lt;b}\frac{t^i}{i!})^{n-2}$$
我们不妨设要计算
$$f(u,t)=(u-\sum_{i&lt;m}\frac{t^i}{i!})^n$$
则
$$\frac{\partial f}{\partial u}=n(u-\sum_{i&lt;m}\frac{t^i}{i!})^{n-1}$$
$$\frac{\partial f}{\partial t}=n(-\sum_{i&lt;m-1}\frac{t^i}{i!})(u-\sum_{i&lt;m}\frac{t^i}{i!})^{n-1}$$
从而
$$nf=\frac{\partial f}{\partial t}+(u-\frac{t^{m-1}}{(m-1)!})\frac{\partial f}{\partial u}$$
也即
$$nf_{i,j}=(j+1)f_{i,j+1}+if_{i,j}-[m-1\le j]\frac{i+1}{(m-1)!}f_{i+1,j-m+1}$$
从而 $j&gt;0$ 时，我们有
$$f_{i,j}=\frac{(n-i)f_{i,j-1}+[j\ge m] (i+1)f_{i+1,j-m}/(m-1)!}j$$
而 $j=0$ 时显然有
$$f_{i,0}=(-1)^{n-i}\binom ni$$
然后我们考虑计算
$$g=(\sum_{i&lt;a}\frac{t^i}{i!})(u-\sum_{i&lt;m}\frac{t^i}{i!})^n$$
此时有
$$\frac{\partial g}{\partial u}=n(\sum_{i&lt;a}\frac{t^i}{i!})(u-\sum_{i&lt;m}\frac{t^i}{i!})^{n-1}$$
$$\frac{\partial g}{\partial t}=n(\sum_{i&lt;a}\frac{t^i}{i!})(-\sum_{i&lt;m-1}\frac{t^i}{i!})(u-\sum_{i&lt;m}\frac{t^i}{i!})^{n-1}+g-\frac{t^{a-1}}{(a-1)!}f$$
$$(u-\frac{t^{m-1}}{(m-1)!})\frac{\partial g}{\partial u}+(\frac{\partial g}{\partial t}-g+\frac{t^{a-1}}{(a-1)!}f)=ng$$
$$\frac{\partial g}{\partial t}=(n+1)g-(u-\frac{t^{m-1}}{(m-1)!})\frac{\partial g}{\partial u}-\frac{t^{a-1}}{(a-1)!}f$$
$$g_{i,j}=\frac{(n-i+1)g_{i,j-1}+[j\ge m] (i+1)g_{i+1,j-m}/(m-1)!-[j\ge a]f_{i,j-a}/(a-1)!}{j}$$
而 $j=0$ 时 $g_{i,j}=f_{i,j}$。
这样直接做就好了。
  ]]></content></entry><entry><title>404 Not Found</title><url>/post/404/</url><categories/><tags/><content type="html"> 想不到吧，/post/404/ 居然是一个单独的页面！
你是怎么发现这个页面的呢？
是在 GitHub 上翻源码吗？还是自己改 url 改进来的？
抑或通过搜索功能？或是随机页面？
来评论回答一下吧！</content></entry><entry><title>Hello World</title><url>/post/hello-world/</url><categories><category>杂项</category></categories><tags><tag>杂项</tag></tags><content type="html"><![CDATA[  MathJax3 不支持行内公式，自闭了。
换用 MathJax2.7 脚本后好多了。
操作了一下，又换回 MathJax3 了。
反斜杠的渲染还是一如既往的玄学，因此现在我采用了 html 的 &lt;div&gt; 来包裹会出现这种问题的情况。这下一劳永逸了。
Hello World！
你好！
When $a \ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are:
$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}$$
$$\begin{matrix}a&amp;b\\c&amp;d\end{matrix}$$
$$\begin{matrix}a&b\\c&d\end{matrix}$$ $$w^{(l)}_{ij} = w^{(l)}_{ij} - \eta\frac{\partial E(W, b)}{\partial w^{(l)}_{ij}}$$ （sample from https://adaning.github.io/posts/33457.htmlby AnNing）
我说，$\{x^L|x^R\}$。
1Hello World！ 2 3你好！ 4 5When $a \ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are: 6 7$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}$$ 8 9$$\begin{matrix}a&amp;b\\\\c&amp;d\end{matrix}$$ 10 11&lt;div&gt; 12$$\begin{matrix}a&amp;b\\c&amp;d\end{matrix}$$ 13&lt;/div&gt; 14 15&lt;div&gt; 16$$w^{(l)}_{ij} = w^{(l)}_{ij} - \eta\frac{\partial E(W, b)}{\partial w^{(l)}_{ij}}$$ 17&lt;/div&gt; 18 19（sample from &lt;https://adaning.github.io/posts/33457.html&gt; by AnNing） 20 21我说，`$\{x^L|x^R\}$`。 一二三四五六1 2 2.1 2.2 3 1#include &lt;stdio.h&gt; 2 3int main() 4{ 5 puts(&#34;Hello World!&#34;) 6 return 0; 7} qwqqwq
  ]]></content></entry><entry><title>Music</title><url>/music.html</url><categories/><tags/><content type="html"> 原本这里是有内容的，但是鸽子了。</content></entry><entry><title>关于我</title><url>/about.html</url><categories><category>杂项</category></categories><tags><tag>杂项</tag></tags><content type="html"> 你好。我是 myee。
我的高中就读于杭州学军中学教育集团文渊中学，大学就读于清华大学。现在（$2025$ 年 $1$ 月）大一。
我的 OI 主要获奖：
APIO2022 线上金牌。 WC2023 金牌。 NOI2023 金牌。 在使用 GitHub Pages 搭建博客前，我用过很长时间洛谷博客，也用过两年左右的 cnblogs（博客园）。
当初使用洛谷博客主要是为了方便（以及洛谷题解需要用博客提交），而后来使用 cnblogs 则是因其高度的自定义以及设置加密文章很令人舒适。
然而很不幸，cnblogs 运营困难，摇摇欲坠，有可能即将倒闭。因此我不得不防患于未然，搭建起这个博客。
该博客采用了 Hugo NexT 主题，故而非常美观。
由于我不是很会在 GitHub 上加密文章，所以我并不会轻易把所有文章传上来。
现在之前的文章都还在鸽，到时候会传的。</content></entry><entry><title>友情链接</title><url>/flinks.html</url><categories><category>杂项</category></categories><tags><tag>杂项</tag></tags><content type="html"> 由于博客评论我还不会弄，如果有需要挂友链的同学可以联系我，我会视情况加入。
评论功能弄好了！有想挂友链的同学在下面发一下就好了，我会视情况加入。
国内用不太了 waline，我也不太会配，急了。有意愿的同学还是联系我吧。
评论系统已换用 giscus，使用 GitHub 账号登录即可评论。
欢迎在下方评论，有想挂友链的同学在下面发一下就好了，我会视情况加入。
你可能需要发的内容：
你的常用 id。 你的头像 avatar。如果不知道可以直接用 https://q1.qlogo.cn/g?b=qq&amp;amp;nk=[你的QQ号]&amp;amp;s=5。 你的博客链接。</content></entry><entry><title>loj3362</title><url>/post/loj3362/</url><categories><category>题解</category></categories><tags><tag>题解</tag><tag>loj</tag></tags><content type="html"> 因为某 hhz 曾经往 XJOI 模拟赛搬了这题，然后现在我要给模拟赛讲题，所以滚回来补题了。
观察 $1$：对于一个形如 WWBB 的子图，如果当前匹配是 $(1,4)(2,3)$，我们换成 $(1,3)(2,4)$ 总更优。
观察 $2$：满足观察 $1$ 的情况，可以被描述为，假设某个 B 和 W 相连，那么当前 B 的后一个 B 一定连着当前 W 的下一个 W。
观察 $3$：在观察 $2$ 的基础上，假设一条线段的两个点在环上的距离为 $d$，那么该线段一定和 $d-1$ 条线段相交。
观察 $4$：在观察 $3$ 的基础上，考虑把白点全部对称到环上对称的位置，然后再计算距离 $d$，那么即为 $n-d-1$ 的贡献。
因此我们的目标转为最小化 $\sum d$。
容易发现，我们假设每个黑点权值是 $+1$，每个白点权值是 $-1$，那么当前问题就转化为了经典的
糖果传递
，直接套结论即可。
总复杂度可以做到 $O(n)$。</content></entry><entry><title>超现实数学习笔记</title><url>/post/surreal-number/</url><categories><category>学术</category></categories><tags><tag>学术</tag></tags><content type="html"><![CDATA[  由于不打算学得太深，决定只记几个简单的内容。全文基本不会有证明。
定义博弈的形式化定义：设所有博弈 $x$ 构成博弈全集 $S$，则每个 $x$ 可以唯一表示为 $\{x^L|x^R\}$ 的形式，其中 $x^L,x^R\subseteq S$。注意 $x^L,x^R$ 是博弈的一个集合，且讨论范围内 $x^L,x^R$ 均为有限集，采取的定义不会出现环。
超现实数的形式化定义：设所有超现实数 $x$ 构成超现实数全集 $S$，则每个 $x$ 可以唯一表示为 $\{x^L|x^R\}$ 的形式，其中 $x^L,x^R\subseteq S$ 且 $\forall a\in x^L,b\in x^R,b\nleq a$。注意 $x^L,x^R$ 是超现实数的一个集合，且讨论范围内 $x^L,x^R$ 均为有限集，采取的定义不会出现环；比较运算会在随后定义。
容易发现这两个定义是类似的，只不过超现实数的定义中还要求所有左部元素均不大于右部元素。习惯上，假设 $x^L=\{a,b,c,\dots\}$，$x^R=\{d,e,f,\dots\}$，我们会简记 $x=\{a,b,c,\dots|d,e,f,\dots\}$。
接下来对超现实数定义比较运算符。
$$y\le x\Leftrightarrow x\ge y\Leftrightarrow\nexists t\in x^R,t\le y\land\nexists t\in y^L,x\le t$$ $$x=y\Leftrightarrow x\ge y\land y\ge x$$ $$y&gt;x\Leftrightarrow x&gt;y\Leftrightarrow x\ge y\land y\ngeq x$$ 可以证明，对于超现实数来说，这个比较运算为全序的。人话就是和我们平常所看到的比较运算符没啥区别。
对博弈我们有类似的定义，但不再是全序；即可能出现 $x\nleq y\land y\nleq x$ 的情况。我们称无法比较的情况为 $x\|y$；而称 $x=y$ 为值相等。$&amp;lt; &amp;gt; = \ge \le$ 这几个运算符本身仍是具有传递性的。
对于超现实数来说，值相等即为相等；对于博弈来说，值相等则不能说明相等。
再定义其余几种运算。其中关于集合的运算表示这集合内部的元素均做该运算后得到的新的集合。 …  ]]></content></entry><entry><title>AGC019D O(n log n) sol (English ver.)</title><url>/post/agc019d/</url><categories><category>题解</category></categories><tags><tag>题解</tag><tag>AtCoder</tag></tags><content type="html"><![CDATA[  Download Chinese ver.Translated by DeepLwith my manual modification.
Firstly, there is no solution if and only if $B_i\equiv0$ and there exists $A_i=1$.
It can always be found that any one of the optimal routes takes the form of a total of $l$ steps to the left and $r$ steps to the right, with the end point $p$ to the left/right of the starting point.
This is easily proved by tweaking, and the answer is
$$2r+2l-p+\text{number of unmatched pairs at the endpoints}$$
where &ldquo;unmatched pairs&rdquo; is defined as either $0$ and $1$ at the same subscript, or $1$ and $0$ at the same subscript.
We might as well enumerate the endpoints and minimize $l+r$.
Then a scheme is legal if and only if any of the $A_i=1$ numbers have ever been at $B_i=1$ (including the endpoints).
This translates into no more than $n$ restrictions, each of the form $l\ge l_j\lor r\ge r_j$, where $l_j/r_j$ denotes how far to at least $1$ in $B$ it would be if it were only to go left/right; $l\ge p$ for a restriction to the left, and $r\ge p$ for a restriction to the right; and finally, $l\ge0$ and $r\ge0$. and $r\ge0$.
In this way we are planning as follows:
$$\min z=x+y$$
$$s.t.\begin{cases}A_1=0\lor x\ge l_1\lor y\ge r_1\newline A_2=0\lor x\ge l_2\lor y\ge r_2\newline\vdots\newline A_n=0\lor x\ge l_n\lor y\ge r_n\newline x\ge[\text{end to left}]p\newline y\ge[\text{end to right}]p\end{cases}$$
Consider solving the plan by graphing.
We draw these restrictions through to the 2D plane, which is a number of $3/4$ planes taking intersections with two half-planes to find the minimum $x+y$ on them.
Noting that $z=x+y$ is a diagonal line when $z$ is constant, we consider just finding the minimum legal point on the contour line.
This can be handled directly by bucket rows and then monotonic stacks. Total complexity $O(n^2)$.
If you notice that the previous constraints are always the same, this problem can actually be done with a scan line to achieve a better complexity!
The total complexity will be $O(n\log n)$ due to the FFT acceleration of the previous &ldquo;number of unmatched pairs&rdquo; contribution.
  ]]></content></entry><entry><title>NOI2023 游记</title><url>/post/noi2023/</url><categories><category>游记</category></categories><tags><tag>游记</tag><tag>图片挂了</tag></tags><content type="html"> Day $0$ 是 7.23，Day $1$ 是 7.24，Day $2$ 是 7.26。
Day $-6$
从华师一飞回杭州。
打 qoj 板子赛。
Day $-5$
模拟赛。
$44+32+0$。
T1 正解没调出来。破大防。
打 qoj 板子赛。
下午不小心撞电风扇上了，受伤了，比较寄。
Day $-4$
模拟赛。
$100+0+100$。
最后一个小时写了 T3 对拍。出题人不给大样例是这样的。
打 qoj 板子赛。
Day $-3$
模拟赛。XJOI。
$90+25+0$。
T1 被卡常了。
打 qoj 板子赛。
Day $-2$
模拟赛。XJOI。
$0+0+0$。
hhz 素质很高。
NOI 考前最后一场模拟赛搬三个题，前两题题意还能假的，第三题不可做。
喜提爆零。
打 qoj 板子赛。
Day $-1$
早上赶飞机，飞去成都。
$10:55\sim13:35$ 的飞机。CA4520。和绍一同一班。
抵达成都双流机场。
徐老师带路。成功带迷路了。
后来工作人员来了，但是徐老师不知道去哪了。于是我们等了很久。
大约 15:00 左右坐上大巴。
很快进了学校。签名墙上签名！
领物资，领到了胸牌、秩序册、两件 T 恤、一个 NOI 徽章等等。还有一大张餐券。
入住寝室。这个寝室看上去很不错啊！室友是 zak sjy dx。
领到了 $10$ 个我的徽章。自己留了一个，剩下的都拿去换了。
qyc 火大了，觉得我应该多订几个。/fendou
吃晚饭。食堂是自助取餐，很舒服！
背笔试。
打 qoj 板子赛。
晚上发了密码条。
Day $0$
背笔试。
上午开幕式。
前来的工作人员名单揭幕了。怎么有 EI？怎么有 EI？怎么有 EI？
畏惧了。
《红旗颂》把耳朵震聋了。哈人。
机器人表演之类的保留节目还在。
背笔试。
下午去试机。试机题目是 NOIp2021。奶一口今年没有交互题。
yyl 说下发了一个 selfEval，来给选手测样例，避免 MLE 之类的傻逼错误。测了下很好用。
笔试题目很轻松满分了。今年怎么又有碰键盘题和丢密码条扣分题啊！
NOIp 花了 1h 切了前 $3$ 题，测试了一下 selfEval 发现很好用。
打 qoj 板子赛。
晚上发了密码条。
Day $1$
半夜里惊醒，一看时间 $2:22$。
去考场前突然想上厕所，问了下工作人员给指了 …</content></entry><entry><title>那些你不要的模板</title><url>/post/template-practice/</url><categories><category>题解</category></categories><tags><tag>题解</tag><tag>做题记录</tag></tags><content type="html"> 打 qoj 板子赛打的。
有的是会的，只是之前没写过。
就题论题，所以写的不一定是正解。
回文自动机
题意 对于 $S$，记 $c_S(T)$ 表示 $T$ 在 $S$ 中的出现次数。对所有回文串 $T$，求 $\max_T(c_S(T) \cdot |T|^2)$。
对于所有数据，$|S| \leq 10^6$。
题解 经典结论：本质不同回文子串只有 $O(n)$ 个。
Manachar 的同时动态维护一下字典树，使用树上倍增快速找 $k$ 级祖先，就好了。
最后树上差分，枚举每个串，计算贡献即可。
区间本质不同子串
题意 给定字符串 $S$，$q$ 次询问，每次给出 $l,r(1 \leq l \leq r \leq |S|)$，你需要求出 $S[l:r]$ 本质不同的子串数量。
对于所有数据，$1 \leq |S| \leq 2 \times 10^5, 1 \leq q \leq 2 \times 10^5$。
题解 建出后缀树，对 $l$ 从大往小扫描线。
动态维护一下每条边最新归属于哪个后缀，容易发现就是对一个点到根的路径染色，使用 LCT 的均摊即可维护。
拿一个 BIT 计算一下贡献，总复杂度 $O(n\log^2n+q\log n)$。
正则二分图匹配
题意 给定一个正则二分图 $G=(X,Y,E)$，其中 $|X|=|Y|=n$ 且每个点的度数均为 $d$，请你求出一个其完美匹配。
对于 $100%$ 的数据，保证 $n\times d\le 2\times 10^6$。
题解 我们打乱所有左部点，然后逐个枚举左部点作为起点，每次步步随机走出一条增广路，消掉增广路的环之后直接增广这条增广路。
可以证明复杂度期望是 $O(n\log n)$ 级别的。
边三连通分量
题意 给出 $N$ 个点 $M$ 条边的无向图，第 $i$ 边是 $(a_i,b_i)$。求出其所有边三连通分量。
$1 \leq N \leq 2\times 10^5$，$1 \leq M \leq 2 \times 10^5$，$0 \leq a_i, b_i &amp;amp;lt; N$。
题解 首先拉出一颗 Tarjan 生成树出来。我们给每条非树边一个 $2^{64}$ 范围内的随机哈希值，然后在树链上异或上这个哈希值。这样每条非树边的哈希值对应了一个集合。 …</content></entry><entry><title>UNR#7游记</title><url>/post/unr7/</url><categories><category>游记</category></categories><tags><tag>游记</tag><tag>图片挂了</tag></tags><content type="html"> 考前两天是联考的 NOI 模拟赛。
Day $-3$
背笔试。
https://duck.ac/beibishi
。
Day $-2$
背笔试。
VP 了 UNR#6 的笔试。第一题 AB 看反扣了 $1\rm pts$。
Day $-1$
联考模拟赛 Day $1$。
开 T1。太困难，不会做。欸我会 $60\rm pts$ 暴力！
开 T2。太困难，不会做。欸我会 $50\rm pts$ 暴力！
开 T3。太困难，不会做。欸我会 $40\rm pts$ 暴力！
写完三个暴力后无所事事，推了一下 T1 还是不会做。
仔细看看 T3 的 $O(nq)$ 暴力，我去这不是 ddp 板子吗。火速写了个 ddp 就过了大样例。
预估得分：$60 + 50 + 100$。
最终得分：$60 + 50 + 100$。
膜 sjy $100 + 100 + 100$。
背笔试。
Day $0$
联考模拟赛 Day $2$。
开 T1。太困难，不会做。欸我会 $O(2^n)$ 暴力！
开 T3。太困难，不会做。欸我会 $O(n^2)$ 暴力！
开 T2。这不是欧拉回路板子？
手玩了一下。诶呀怎么有重边的。
稍微分类讨论了一下，把重边去掉了，然后发明了一个欧拉回路，然后就过大样例了。
大样例大小只有 $10$。很慌，写了个拍。（@_RSY_，你是懂 FJOI 的）
没过拍。欸我怎么只处理了第一个联通块啊。修了下过拍了。
给 T3 暴力卡了卡常。
给 T1 拼了个乱搞。
预估得分：$30 + 100 + 20$。
最终得分：$50 + 100 + 40$。
T1 数据水多拿了 $20\rm pts$，T3 没看到后面有个特殊性质可以保证 $n$ 很小，多拿了 $20\rm pts$。
膜 zak、lhf $100 + 100 + 100$。Qiuly 怎么这么演。
背笔试。
开打 UNR 笔试。
哇塞怎么这么牛的，不用手动提交答案了。
今年题面怎么这么魔怔。
很轻松 $100\rm pts$ 了。
L 神没背到那个切换虚拟终端和桌面环境的两个快捷键，挂了 $2\rm pts$。（Ctrl+Alt+F(1-6) &amp;amp;amp; Alt+F2）
很多人 NOI 中文含义没加青少年，挂了 $1\rm pts$。其实 NOI 官网
标题就叫这个。。。
晚上 sdsz 杂题选讲。只会其中没几题， …</content></entry><entry><title>loj3959</title><url>/post/loj3959/</url><categories><category>题解</category></categories><tags><tag>题解</tag><tag>loj</tag></tags><content type="html"> 惊奇地发现我的赛时做法也可以通过转化一下计算式优化到 $O(n+m)$。或许也算是一种另解？
首先，我们考虑把后手的决策视为图上的一个自环或一条边。对于每条边，你要对其选择其连接的一个点，且使得其满足两两不同。
对先手的决策，则意味着对这个点 / 边的额外代价，包括
无额外代价。（$|S\cap T|=0$） 选其中一个点时会有 $1$ 的额外代价。（$|S\cap T|=1$） 选被先手钦定的点时有 $1$ 的额外代价。（$|S\cap T|=2$） 不妨考虑在建出那张图之后，对每个联通块分别处理。
如果点数小于边数，则一定无解。
如果点数等于边数，那么我们可以发现这总是一颗基环树，把环外部分贡献直接算出来，然后环上部分仅两种决策，我们直接统计有多少个左方向的额外代价、右方向的额外代价、任意方向的额外代价，设为 $a,b,c$，则答案为 $\min{a+c,b+c,\lfloor\frac{a+b+c}2\rfloor}$。自环的情况最好手动特判。
对于剩下的情况，该联通块形如一颗树，考虑怎么解决。
外面注意到恰好有一个点不会被任一条边所选择，考虑在那个点处计算答案。显然这样的贡献是以该点为根的叶向树与额外代价的实际选法相同的边的个数。
对于无额外代价或者额外代价为选一个定点时才有的边，我们发现我们总可以把其额外代价通过一次换根 dp 直接传递到每个点 $p$ 上，作为点权 $a_p$。然后把其两端的点缩在一起，将点权取 $\min$，不影响答案。这样，剩下的边均为「被钦定的部分存在额外代价」的边，而对后手来说，其选择一个点为根的代价即为其 $a_p+\text{被钦定向外的边的数目}$。
我们注意到，如果我们无根树转有根树，钦定一个整颗树的根 $r$，那么对于任意一条 $r$ 到叶子的路径，我们总可令上面若干条边向钦定为根向，下面若干条边钦定为叶向，由调整法这样总不劣。
那么，钦定为根向的边一定和根联通，构成一个联通块。
也就是说，钦定为叶向的边，总可以拆成若干组「子树内的边与子树向外的边」的无交并。
而对于一个节点 $p$，考虑如果将根换为其，则我们总可以将 $r$ 到其的路径上的边的贡献翻转。于是其答案即为 $a_p+\text{树上叶向边数目}+p\text{ 到 }r\text{ 的根向边数目}-p\text{ 到 }r\text{ 的叶向边数目}$。
…</content></entry><entry><title>uoj241</title><url>/post/uoj241/</url><categories><category>题解</category></categories><tags><tag>题解</tag><tag>uoj</tag></tags><content type="html"><![CDATA[  公式过长警告。
考虑只有相邻不同怎么做。也就相当于是 $2\nmid n$ 的答案。
这个是经典题。
假设答案为 $f_n$，那么我们枚举第一个元素，有 $m$ 种选法，其余元素由于要和前一个元素不同，有 $m-1$ 种选法。这样可能会统计首尾元素相同的情况，而这种情况的数目为 $f_{n-1}$。
于是我们有
$$f_n=m(m-1)^{n-1}-f_{n-1}$$
边界不妨为 $f_0=m,f_1=0$；容易发现这样恰好合法。
也即
$$f_n=[n=0]m+[n&gt;0]m(m-1)^{n-1}-f_{n-1}$$
那么写成 GF 就有
$$f=m+\frac{mz}{1-(m-1)z}-zf$$
$$f=\frac{m-m(m-2)z}{(1+z)(1-(m-1)z)}$$
随便写个常系数齐次线性递推就好啦。
通项其实也可推出；即为
$$f_n=(m-1)^n+(m-1)(-1)^n$$
总复杂度 $O(\log n)$。
然后由于本题要求相对的位置也要不同，我们考虑 $2|n$ 的情况怎么做。
我们考虑容斥。
我们设 $a_n$ 为满足首尾颜色确定且不同，且相邻元素不同的长度为 $n+1$ 的序列的数目；$b_n$ 为满足首尾颜色确定且相同，且相邻元素不同的长度为 $n+1$ 的序列的数目。规定 $a_0=b_0=0$。
我们设 $a_n^2$ 与 $b_n^2$ 分别对应 GF $\check A$ 和 $\check B$。
则钦定 $k$ 个对位必须相同的方案对答案的总贡献（$k&gt;0$）为
$$(-1)^k\frac{n}{2k}[z^{n/2}]\sum_tf_t[u^t] (u\check A+\check B)^k\\=(-1)^k\frac{n}{2k}[z^{n/2}](((m-1)\check A+\check B)^k+(m-1)(-\check A+\check B)^k)$$ 设 $G=(m-1)\check A+\check B$，$H=-\check A+\check B$，我们按 $k$ 加和，则答案即为
$$\frac n2[z^{n/2}]\sum_k\frac{(-1)^k(G^k+(m-1)H^k)}{k}=\frac n2[z^{n/2}] (\ln\frac{1}{1+G}+(m-1)\ln\frac{1}{1+H})=[z^{n/2-1}] (\frac{-G&rsquo;}{1+G}+\frac{(1-m)H&rsquo;}{1+H})$$
是的，这仍然是一个线性递推！
最后加回 $k=0$ 时的答案即可。
然后问题来到如何计算 $G,H$ 这边。
注意到 $[n&gt;0]f_n=mb_n$，于是我们有
$$B(z)=\sum_nb_nz^n=\frac{(m-1)z^2}{1-(m-2)z-(m-1)z^2}$$
而 $m(m-1)a_n=f_{n+1}$，于是
$$A(z)=\sum_na_nz^n=\frac{z}{1-(m-2)z-(m-1)z^2}$$
考虑怎么解决 $\check A$ 和 $\check B$。
由于 $B=(m-1)zA$，故 $\check B=(m-1)^2z\check A$，我们接下来只考虑 $A$ 怎么解决。
我们有
$$a_n=\frac{(m-1)^n-(-1)^n}{m}$$
从而
$$a_n^2=\frac{(m-1)^{2n}-2(1-m)^n+1}{m^2}$$
于是
$$m^2\check A=\frac{1}{1-(m-1)^2z}-\frac{2}{1+(m-1)z}+\frac{1}{1-z}$$
从而
$$\check A=\frac{z-(m-1)z^2}{1-(m^2-3m+3)z-(m^2-3m+3)(m-1)z^2+(m-1)^3z^3}$$
（不妨动手一试；这里消得很干净）
接下来的内容比较混乱邪恶。由于太难算了所以使用了 https://zh.numberempire.com/expressioncalculator.php辅助计算。
于是
$$G=\frac{(m-1)z-(m-1)^3z^3}{1-(m^2-3m+3)z-(m^2-3m+3)(m-1)z^2+(m-1)^3z^3}$$
$$1+G=\frac{1-(m^2-4m+4)z-(m^2-3m+3)(m-1)z^2}{1-(m^2-3m+3)z-(m^2-3m+3)(m-1)z^2+(m-1)^3z^3}$$
$$G&rsquo;=\frac{(m^6-7m^5+21m^4-34m^3+31m^2-15m+3)z^4+(2m^5-14m^4+38m^3-50m^2+32m-8)z^3+(m^4-8m^3+19m^2-18m+6)z^2+m-1}{(1-(m^2-3m+3)z-(m^2-3m+3)(m-1)z^2+(m-1)^3z^3)^2}$$
$$\frac{G&rsquo;}{1+G}=\frac{(m^6-7m^5+21m^4-34m^3+31m^2-15m+3)z^4+(2m^5-14m^4+38m^3-50m^2+32m-8)z^3+(m^4-8m^3+19m^2-18m+6)z^2+m-1}{(-m^6+7m^5-21m^4+34m^3-31m^2+15m-3)z^5+(m^6-9m^5+35m^4-73m^3+85m^2-52m+13)z^4+(2m^5-15m^4+48m^3-79m^2+66m-22)z^3+(m^4-9m^3+27m^3-36m+18)z^2+(-2m^2+7m-7)z+1}$$
$$H=\frac{-z+(m^2-m)z^2-(m-1)^3z^3}{1-(m^2-3m+3)z-(m^2-3m+3)(m-1)z^2+(m-1)^3z^3}$$
$$1+H=\frac{1-(m^2-3m+4)z-(m^2-4m+3)(m-1)z^2}{1-(m^2-3m+3)z-(m^2-3m+3)(m-1)z^2+(m-1)^3z^3}$$
$$H&rsquo;=\frac{(m^6-8m^5+25m^4-40m^3+35m^2-16m+3)z^4+(2m^5-12m^4+32m^3-44m^2+30m-8)z^3+(-m^4+7m^2-12m+6)z^2+(2m^2-2m)z-1}{(1-(m^2-3m+3)z-(m^2-3m+3)(m-1)z^2+(m-1)^3z^3)^2}$$
$$\frac{H&rsquo;}{1+H}=\frac{(m^6-8m^5+25m^4-40m^3+35m^2-16m+3)z^4+(2m^5-12m^4+32m^3-44m^2+30m-8)z^3+(-m^4+7m^2-12m+6)z^2+(2m^2-2m)z-1}{(-m^6+8m^5-25m^4+40m^3-35m^2+16m-3)z^5+(m^6-10m^5+39m^4-80m^3+91m^2-54m+13)z^4+(2m^5-15m^4+48m^3-79m^2+66m-22)z^3+(m^4-8m^3+25m^2-34m+18)z^2+(-2m^2+6m-7)z+1}$$
只能说过于非人类了。
然后最后写一个常系数齐次线性递推就完工啦。
这整道题目的答案容易发现还是一个有理函数，所以直接上 BM 也是可以的。
参考代码。
  ]]></content></entry><entry><title>THUPC2023 游记</title><url>/post/thupc2023/</url><categories><category>游记</category></categories><tags><tag>游记</tag><tag>图片挂了</tag></tags><content type="html"> 2023.2
THUPC 报名！
和 unputdownable，猫猬兽组队，队名 XJ 五队。
devin 让我们填毕业年份 2028。
收货地址填了 重庆市第114514中学冯阳阳纪念谷学校。
upd 性别填 其他 被拒了。
2023.3.4
THUPC 2023 初赛测试赛！
$3$ 月 $4$ 日 $13$ 点联络群消息：
1## OJ网址 2 3thupc2023.thusaac.com 4 5## 环境测试 (https://thupc2023.thusaac.com/contest/4/home) 6 7- 时间：2023/3/4 13:00 ~ 2023/3/5 10:00 8- 语言及编译选项与正式初赛相同 9- 所有参加环境测试的选手**共用**如下账号，因此您的提交能够被其他人看见 10 密码条： 11 username: thupc_test 12 password: ec76d8 13- 正式比赛使用的用户名和密码条将在报名截止（2023/3/5 10:30）后生成并通过报名网站 (https://signup.thupc2023.thusaac.com/)发放 然后发现公用号可以发提问！
1已解决 提问 THUPC测试 03-04 13:14:07 解决 THUPC测试 03-04 13:14:22 2我， 03-04 13:14:07： 3膜拜国际特级大师周康阳大佬 乐。
然后此时由于 NOI 春测刚结束，没管，去口胡了春测，感觉梦回普及组！不过被最后一道 Itst 题拉回现实了。
然后开摆。
大概下午 $3$ 点半左右开始做题。
题面下载
。
然后去提问区问了一句：
1我， 03-04 15:34:54： 2测试赛题解赛后会公开吗 回复是
1管理员， 03-04 16:54:54： 2这三道题是「CodePlus 8 × HWS第五期 - 决赛」复刻，已经帮您联系出题人，希望他们不鸽🙏 发现没人过 B，开题看了眼。
感觉是憨憨数位 dp，枚举取模后结果即做完。
然后开始写，第一次交 MLE 了（开了 map），第二次交 TLE 了（递归大常数），最后卡了卡常才过。
代码：
1// 膜拜国际特级大师周康阳大佬，今天在 THUPC 测试赛首页称您为大夏尊贵的大名，一股敬佩之油生然而，您在 THUPC 测试赛为国争光，扬我华威名，向您献上最 …</content></entry><entry><title>APIO2023游记</title><url>/post/apio2023/</url><categories><category>游记</category></categories><tags><tag>游记</tag><tag>做题记录</tag></tags><content type="html"> 没报名 APIO。
Day $1$ 是 5.20。
Day $-2$
今天上午怎么有模拟赛。大为震撼。不过徐老师和我们说这场我们可以鸽掉。于是就鸽子了。
就看了眼 T2，会了。听 zak 说这是
不归之人与望眼欲穿的人们
。
应徐教练要求，上午我讲课，大概讲了一下【数据删除】，还拿了松松松的【数据删除】做例题，结果讲得太简单，被同学们打爆了！
中午发现自己 QQ 被封七天了，怎么会是呢。原来是在 LA 群发了某些【数据删除】的东西啊。
下午是【数据删除】和长沙一中的【数据删除】来讲课，前者介绍了好几个科技（【数据删除】，【数据删除】和【数据删除】），而后者介绍了三道神秘题。
我讲的内容，直接，相形见绌啊！
虽然课件做得不全（最后那道例题没加），但是还是挂一下吧：
下载链接
。解压密码是三个人的 id 字符串拼在一起，全小写。
晚上带 cmll02 去了趟医院。
一天下来只写了 $2$ 道水题。太颓了。太颓了！
Day $-1$
高一的同学们、高二的 sjy 还有长沙一中来集训的同学们都启程了。
留校的只有我，L 神（SegmentTree），和外省来集训的同学。
和 L 神一起 UER 竞速。（？）
以为自己给【UER #3】开学前的涂鸦整了个很厉害的做法，结果 L 神说 hehezhou 博客里有
？
然后就给【UER #5】万圣节的糖果整了个
更简单的做法
？双射啥的还是太神秘了。
然后写了道
小模拟
。
Day $0$
和 L 神一起做 UOJ。
秒掉了
【UR #10】世界线
。
L 神：你这做法这么这么怪啊。
我：我过了。
然后 L 神写了一遍，97pts。
为什么呢。因为没有加随机化或者启发式。
秒了两道清华集训 2015，写了一道，另一道没写。
然后和 L 神竞速
【清华集训2015】灯泡测试
，我先 A 了然后拿了最优解，然后 L 神觉得我的做法不够优秀，写了个更厉害的做法怒拿最优解。
然后写
【清华集训2015】V
，光荣被卡常，卡了一会才过，被 L 神暴打。
写了一道玄学搜索题，然后猜了
某道题目
的结论，问了下 L 神，他说是对的。代码还没写。
看了眼 APIO 的同学们发来的课件，感觉这些东西，对我，还是太困难了！
开摆。
Day $1$
把昨天那题的代码补了。糊了一个匈牙利上去，拿了最优解，效率是第二名的三倍左右。
怎么大家都写的网络流退流 …</content></entry><entry><title>uoj56</title><url>/post/uoj56/</url><categories><category>题解</category></categories><tags><tag>题解</tag><tag>uoj</tag></tags><content type="html"><![CDATA[  总览目前 $90$ 分，容易做到 $91$ 但是目前没必要。
基本要求：$0\le n\le10000$，$0\le m\le20000$，$0\le w\le20000$。无重边，可以有自环。
$10$ 个测试点的任务和更多限制：
test 1：邻接矩阵。$k=0$，$n\le500$。 test 2：单源最短路。$k=10$。 test 3：全源最短路（似乎有锅）。$k=11$，$n\le100$。 test 4：单源次短路。$k=12$。 test 5：强连通分量。$k=20$。 test 6：集合划分哈希。$k=21$，$n\le10$ test 7：集合划分单调性哈希。$k=22$，$n\le20$。 test 8：二分图最大匹配。$k=30$，$n\le100$。 test 9：二分图最大匹配，某种实现的匈牙利算法构造。$k=31$，$n\le20$。 test 10：SPFA 过程中的队列。$k=13$，$n\le500$，$m\le3000$。 要对这些东西反推。$p$ 在大多数测试点表示边的数目，test 1,5,10 除外：test 1 中总有 $p=0$，test 5 中 $p=\text{强连通分量数目}$，test 10 中 $p=\text{队列长度}$。
test 1显然。
1int main() 2{ 3 freopen(&amp;#34;nm1.in&amp;#34;,&amp;#34;r&amp;#34;,stdin); 4 freopen(&amp;#34;nm1.out&amp;#34;,&amp;#34;w&amp;#34;,stdout); 5 uint n,k,p;scanf(&amp;#34;%u%u%u&amp;#34;,&amp;amp;n,&amp;amp;k,&amp;amp;p); 6 std::vector&amp;lt;std::pair&amp;lt;uint,uint&amp;gt; &amp;gt;V; 7 for(uint i=0;i&amp;lt;n;i++) 8 for(uint j=0,o;j&amp;lt;n;j++) 9 { 10 scanf(&amp;#34;%u&amp;#34;,&amp;amp;o); 11 if(o)V.push_back({i,j}); 12 } 13 printf(&amp;#34;%u %u %u\n&amp;#34;,n,(uint)V.size(),k); 14 for(auto s:V) 15 printf(&amp;#34;%u %u …  ]]></content></entry><entry><title>UOJ随做</title><url>/post/uoj-record/</url><categories><category>题解</category></categories><tags><tag>题解</tag><tag>做题记录</tag></tags><content type="html"><![CDATA[  怎么都做过 uoj Round。
只收录 UOJ 自己的题目，一些官方比赛题就算了。部分 bzoj 等处收录的题目也放上来。
没写题解不意味着没做，有的忘了写或者太草率了就算了。
部分前言删了。
【UER #1】DZY Loves Graph题解 操作树一定形如一个毛毛虫。
考虑可撤销并查集维护联通块。
对于操作树上主干边暴力进行修改操作。
对于非主干边，可以只计算出答案。
加一条边可以使用并查集查询，删若干边的答案可以直接调之前某个版本的答案。
总复杂度 $O(n+q\log n)$。
【UR #1】缩进优化题解 考虑枚举每个 $x$ 计算答案。
假设值域为 $v$，我们只用知道若干区间内的总和及带权和即可。
使用前缀和即可维护。
总复杂度 $O(n+v\log v)$。
【UR #1】外星人题解 先排序，然后考虑有效的数一定单调减，我们在这些位置决策。
假设 $a_1\ge a_2\ge a_3\ge\dots\ge a_n$。
假设 $f_{i,v}$ 表示考虑到第 $i$ 项，模后值为 $v$ 的方案数。
特别的，$f_{0,v}=[v=x]$。
显然
$$f_{j,v\bmod a_j}\leftarrow\frac{(n-i-1)!}{(n-j)!}f_{i,v}\quad(i&amp;lt;j)$$
于是直接前缀和优化 dp 就是 $O(nv)$ 的了。
【UR #2】跳蚤公路题解 upd：这个做法假了。
注意到发财等价于路径上存在负权环。
只用计算每个源点可能到达的点往自己在 $x$ 在什么范围时可能有负权环，最后把其所能到达的点更新一下即可。
我们可以把每个 SCC 拆开来考虑。对每个 SCC 设其中一个点 $s$ 作为源点即可，容易发现此时不存在负环等价于不存在经过 $s$ 的负环。
设 $f(p,j)$ 为从 $s$ 点到 $p$ 点经过 $j$ 个 $x$ 的情况下剩余部分的最小代价。
如果 $f(s,0)=-\infty$，显然始终存在负环。
否则如果 $f(s,0)=0$，假设 $f(s,a)$ 与 $f(s,b)$ 两项将导致 $\mathbb R$ 上 $x$ 解集为空（$a&amp;lt;0&amp;lt;b$），则有 $\min{f(s,a)+ax,f(s,b)+bx}&amp;lt;0,\forall x\in\mathbb R$， …  ]]></content></entry><entry><title>3-smooth 数相关</title><url>/post/3-smooth-number/</url><categories><category>学术</category></categories><tags><tag>学术</tag></tags><content type="html"><![CDATA[  算是 OI 弱相关的东西（？
因为见到了好几个可以这么嗯搞的东西，所以发出来看看。
3-smooth 数如果一个正整数的所有素因子均不大于 $3$，我们称之为 3-smooth 数。
容易发现，3-smooth 数的一个等价定义就是能表示成 $2^x3^y$ 的数，其中 $x,y\in\mathbb N$。
你可以在 OEIS A003586中看到若干 3-smooth 数，以及相关的近似级别等信息。这里摘录其的前若干项：$1,2,3,4,6,8,9,12,16,18,24,27,32,36,48,54,64,72,81,96$。
对于任意一个正整数 $n$，其总可以分解成 $2^x3^yz$ 的形式，其中 $2\nmid z\land3\nmid z$，也即可以分解成一个 3-smooth 数乘上 $z$，其中 $z\bmod6\in{1,5}$。
这样我们就可以以 $z$ 为代表元来划分等价类了。
即，当我们要考察 $\le n$ 的所有正整数时，我们可以枚举 $z$，然后对剩余部分的 3-smooth 数进行考虑，容易发现也就是 $\lfloor n/z\rfloor$ 内的所有 3-smooth 数。
当要考察 $\le n$ 的所有 3-smooth 数时，我们可以把其画成 Young 表的形式来考虑。
即，注意到当 $y$ 增加 $1$ 时，可能最大的 $x$ 必定会恰好减少 $1$ 或者 $2$。
譬如，如果我们要考察 $\le100$ 的所有 3-smooth 数，可以画成这样的形式：
$$\begin{matrix}1&2&4&8&16&32&64\\3&6&12&24&48&96\\9&18&36&72\\27&54\\81\end{matrix}$$ 也就是前面所摘录的那些项。
容易发现使用这个形式我们就可以估计 $\le n$ 的 3-smooth 数的数目级别了。毛估估大概就是 $\frac{\ln^2n}{2\ln2\ln3}+O(1)$ 的样子。
例题因为实在没啥知识点，直接丢例题了。
希尔排序使用 3-smooth 数的希尔排序是 $O(n\log^2n)$ 的。
bzoj2734 [HNOI2012]集合选数枚举 $z$，直接对着 Young 表的一列状压就完了。
复杂度是容易分析的。
SPOJ SUMMING神秘题，可以看这篇题解。
题解里给出了对第 $n$ 项求取的一个不错的近似。
八校联考题 约树这道题目就把上面那个 Young 表的作用体现得淋漓尽致了。
题解：【数据删除】
啥时候那题公开了再补吧。
  ]]></content></entry><entry><title>当用 SA 来建后缀树</title><url>/post/when-building-st-with-sa/</url><categories><category>学术</category></categories><tags><tag>学术</tag></tags><content type="html"> 因为学不会什么串串技术，所以我只会 SA，至于 SAM 啥的我一窍不通，而后缀树也只知道定义！所以别和我说 Ukkonen 算法，因为我不会。
以下假设原串 $\text{S}$ 长度为 $n$，我们在后缀数组 $\text{SA}$ 开头插入一个空串，用 $\text{H}$ 数组（好像通常叫做 $\text{height}$ 数组？）表示 $\text{SA}$ 上相邻两个串的 $\operatorname{lcp}$ 长度；即 $\text{SA}0=\varnothing$，$\text{H}{k}=\operatorname{len}(\operatorname{lcp}(\text{SA}{k-1},\text{SA}{k}))$。
建立 $\text{SA}$ 的复杂度一般是 $O(n\log n)$ 或者 $\Theta(n)$ 的，建立 $\text{H}$ 的复杂度一般是 $\Theta(n)$ 的。我们以下就不妨认为该部分预处理的复杂度为 $O(n\log n)$ 的。通常来说，只要 SA 部分的常数实现得足够好，该部分就不会成为瓶颈。
后缀树是由原串 $\text{S}$ 的每个后缀串所组成的 Trie。容易发现其节点个数是 $O(n^2)$ 的。
后缀树的特殊之处在于，其仅仅只用记录 $\Theta(n)$ 个后缀的信息。
因此，我们其实并不用建出后缀树作为 Trie 的本身，而只用建出其对应的压缩 Trie 即可。
怎么办？
注意到压缩 Trie 其实就是由各个后缀所对应的节点构成的一颗虚树，我们只用建出这颗虚树即可！
容易发现，$\text{SA}$ 本身的顺序就是这些后缀树上关键点按 dfn 序排列所得结果，而 $\text{H}$ 数组标识着 $\text{SA}$ 序上相邻两个关键点的 $\text{lca}$ 深度。于是我们直接按 $\text{SA}$ 序插入节点即可建出虚树。
这样我们就建出了一颗压缩后的后缀树。
如果想要每个关键节点都是叶子节点从而来简化讨论，我们通常可以在原串 $\text{S}$ 的末尾添加一个特殊字符 $\tt$$，这样每个后缀都是互不包含的，并且 $\operatorname{lcp}$ 大小不会发生改变。
例题 区间本质不同子串个数
我们先建出一颗后缀树。
对左端点从右往左作扫描线，每次加入一个后 …</content></entry><entry><title>飞机误点时胡的一个筛子</title><url>/post/sieve-back-hangzhou/</url><categories><category>学术</category></categories><tags><tag>学术</tag></tags><content type="html"> 回杭州的路上胡的。
其实是模拟赛考了一个积性函数前缀和，然后我由于生病没打，所以只胡了，然后由于不想整洲阁筛，所以胡了一个筛子。
应该比较简单，适用范围也较小，大致能搞 DIVCNTK 这种满足 $f(p)=C$ （常数）且 $f(p^a)$ 可以快速求的，不过复杂度不是很优，常数也不小。
之前我只会 $O(Cn^{2/3})$ 的块筛，后来发现稍作改动即可做到 $O(n^{2/3}\log C)$。
优点在于难度很小。仅涉及到 PN 筛和快速幂的倍增。不过由于比较简单，相信大家自己以前也发明过。
我们构造 $h_C=1 * 1 * 1 * \dots * 1$（$C$ 个恒等函数 $1$，$* $ 表示狄利克雷卷积），容易发现 $h_C(p)=f(p)=C$。
使用 PN 筛，
$$\sum_{i=1}^nf(i)=\sum_{j\textrm{ is PN}}(f/h_C)(j)\sum_{k=1}^{\lfloor\frac nj\rfloor}h_C(k)$$
线筛预处理出 $n^{2/3}$ 以内的部分，我们只用得到 $h_C$ 的块筛即可做到在 $O(n^{2/3})$ 内获得 $f$ 的块筛。
当 $C\le1$ 时，$h_C$ 的块筛是平凡的。
当 $2\nmid C$ 时，由于 $h_C=h_{C-1}* 1$，故
$$\sum_{i=1}^nh_C(i)=\sum_{i=1}^{n}h_{C-1}(i)\left\lfloor\frac ni\right\rfloor$$
当 $2|C$ 时，由于 $h_C=h_{C/2}* h_{C/2}$，故
$$\sum_{i=1}^nh_C(i)=\sum_{i=1}^{n}h_{C/2}(i)\sum_{j=1}^{\left\lfloor\frac ni\right\rfloor}h_{C/2}(j)$$
对 $n^{2/3}$ 以内进行线筛，更高部分进行数论分块，即可做到单行转移 $O(n^{2/3})$。
由于中途一共会经过 $O(\log C)$ 层，总复杂度 $O(n^{2/3}\log C)$。
upd：这个就是所谓
冷群筛
的一个特殊情形。</content></entry><entry><title>ZJOI2023 游记</title><url>/post/zjoi2023/</url><categories><category>游记</category></categories><tags><tag>游记</tag><tag>图片挂了</tag></tags><content type="html"><![CDATA[  正赛在 2023.4.1 - 2023.4.2。
愚人节省选。挨创。
前情提要：$\rm NOIP$ $\rm297pts$ 苟上 ZJ 队线。
其实前面一长串（Day $-25\sim-5$）是纪中集训游记，不过比较早的内容可能记不太起来了。
Day $-26$THUPC 初赛，打拉垮了。只过了 C。
Day $-25$飞去中山纪中集训。住的女生宿舍。
Day $-24$清澄模拟赛。hhz &amp;amp; lk Round。
打了 Rank $2$，上去介绍了 T1 的神秘做法。
T2 是什么 SAM 题，看不懂题，开摆。
Day $-23$清澄模拟赛。asdfz &amp;amp; zsjz Round。
垫大底，破大防。
Day $-22$清澄模拟赛。tyy &amp;amp; lh Round。
前两题 tyy 题，一开始的数据甚至只有样例。
用随机撒点树分块冲过去了 T1。
lh 出了神秘高精度题。于是联考风行九雷唱。
Day $-21$听 hsy xxy讲题。开摆。
Day $-20\sim-19$GDKOI，被打爆了！
游记可以自己去看。
Day $-18$清澄模拟赛。liqingyang Round。
给 T1 整了一个非常好写的 $O(kn^{1.34})$ 做法，其中 $k=10$。
Day $-17$清澄模拟赛。xcyle Round。
两道结论题 + 一道神秘高消题。自闭。
Day $-16$清澄模拟赛。zsjz Round。
T1 大分类讨论题没开，急了。
T2 神秘构造题，急了。
T3 赛时重造数据却没有重测，急了。
下午听 zxy讲题。开摆。
qsnkj来通知，ZJOI 改强制 Linux 了。开始用虚拟机。
Day $-15$听 bnds 讲题。开摆。
Day $-14$清澄模拟赛。asdfz Round。
切了 $2$ 题，拿了 Rank $6$。
T1 转化成求 $n$ 个低次有理分式之和的连续点值，随便写了个点值平移秒了。听说 std 写了多点求值，绷。不过也许有趣的地方应该在于乘 $e^z$ 来对 $f\leftarrow z(f&amp;rsquo;&amp;rsquo;+2f&amp;rsquo;+f)$ 进行变换的过程？
T2 转化后是大施罗德数（OEIS A006318），随便推了个 ODE 秒了。其实之前模拟赛里有过这种东西。 …  ]]></content></entry><entry><title>GDKOI2023 游记</title><url>/post/gdkoi2023/</url><categories><category>游记</category></categories><tags><tag>游记</tag></tags><content type="html"> 因为在广东集训，我们都要参加 GDKOI2023 来试手。
正赛在 3.11，3.12 两天。
Day 0
上午是照常的讲题，感觉很有意思。
下午纪中教练给我们发了 GDKOI 2021 题面。
口胡到了 Day 2 的 T3，T4 还没胡。
Day 1
我是预言家！
三题四小时，$8:30\sim12:30$。
没有大样例，稍微大一点的样例也很小。
T1 一看，这不是憨憨题，码了个 modint。
T2 一看，推了个容斥，推出通项式，推出递推式，发现不会啥正经做法。分块 FFT 也没写，预估 $40\sim60$。
T3 一看，容斥 + 异或卷积 + 集合幂级数随便做，写了个 $O(n^23^n+2^n\log v)$ 的东西，光荣没过样例二，挂成 $10$ 分。
怎么三道 $998244353$ 的啊？alpha 快乐场。
听说 alpha $100 + 100 + 80$，zak $100 + 100 + 100$，感觉很厉害。
alpha T2 用 ODE 自动机理论爆标了，做到了根号甚至 $\log^2$。/bx
原来是 wxw 场啊，咋三道原啊。
然后听说 alpha T3 挂成 $20\rm pts$ 了。
T3 std 咋是 $O^*(4^n)$ 的啊。
LA 群内多头：
「待会大家都知道 wxw 搬自己作业到模拟赛里了」
「一定不能让大家知道 wxw 搬自己作业到模拟赛里了」
「你们不要再强调 wxw 搬自己作业到模拟赛里了啊」
听说 T1 2.7e8 读入，没用 fread 的都 gg 了。
晚上把 GDKOI 2021 口胡到了 Day 3 T3，最后一题没看。
Day 2
进场前听说 zak Day 1 $299\rm pts$。
神的怜悯.jpg。
开场一看，一个 ds，一个 $998244353$，一个 ds。
T1 一眼偏序，一个树剖，一个换根，一个扫描线，一个 BIT 拍上去就完了。
T2 没思路，推出了子集 dp，FMT 优化一下是 $O(nk2^n)$ 的，矩乘是 $O(8^n\log k)$，稍微卡卡常，大概是 $20\sim60$。
T3 感觉很 In a Trap
啊！感觉不会啥 polylog 做法，猛的一个根号分治 + 根号平衡冲上去，复杂度 $O((n+q)\sqrt n)$，也没拼暴力，预估 $20\sim100$。 …</content></entry><entry><title>GDKOI2021 口胡</title><url>/post/gdkoi2021/</url><categories><category>游记</category></categories><tags><tag>游记</tag><tag>题解</tag><tag>做题记录</tag></tags><content type="html"> 因为在广东集训，我们都要参加 GDKOI2023 来试手。
听说 GDKOI2021 是三天，每天 $4$ 小时 $4$ 题，省选难度，并且没有大样例。（p.s. GDKOI2022 未举办）而且评测机似乎还是 g++ 4.8.4。
然后由于是非正式选手，我们会在纪中机房打，用的机子会统一是只有 g++ 4.9.2 的 Windows 神秘机。不过听说评测环境会是 NOI Linux 2.0。
反正是，纪中教练（Update: 由 Alpha 从教练那边讨来的）给了我们 GDKOI2021 三天的题面，然后手上也没有可以自己交的地方（没有 gmoj
帐号，注册也没用），因此打算开始口胡！
题面下载链接
。
Day 1
A
给你一张 $n$ 个点 $m$ 条边的无向图，你要把点集分成两部分，使得两个点集之间的边的边数达到一半的总边数。数据保证有解。
保证无自环，重边按重数计。
$n\le10^5$，$m\le2\times10^5$。
考虑对点集增量。
每增加一个点，考虑其和已有的两个点集中谁的边数更少，加入那个点集即可。
复杂度 $O(n+m)$。
B
给定长为 $n$ 的序列 $a_1,a_2,\cdots,a_n$。
我们设 $f_{l,r}=(r-l+1)\min_{l\le k\le r}a_k\quad(1\le l\le r\le n)$，求出从小到大排名在 $L$ 到 $R$ 之间的各个 $f$ 值。
$1\le n\le3\times10^5$，$0\le a_i\le10^9$。
$1\le L\le R\le n(n+1)/2$，$R-L+1\le3\times10^5$。
这个，是不是，可以加进 XJCS，作为单调栈基础练习题啊！@devinwang
写个单调栈，建出笛卡尔树，我们就可以知道对于每个 $\min a$，其向左、向右扩展的距离。
然后我们考虑二分答案，对每个值 $w$ 查询有多少对 $l,r$ 满足 $f_{l,r}&amp;amp;lt;w$；答案显然不超过 $O(nv)$ 级别，因此只用 $O(\log(nv))$ 轮二分即可解出第 $L$ 大的数对应的权值，以及有多少数小于之。
然后我们考虑下一个数怎么求：我们先把相同的 $w$ 尽可能取空，这样我们下一个只用考虑 $&amp;amp;gt;w$ 的数。然后我们对每个 $\min a$ 开一个对应了元素的 …</content></entry><entry><title>loj3076</title><url>/post/loj3076/</url><categories><category>题解</category></categories><tags><tag>题解</tag><tag>loj</tag></tags><content type="html"> 参照 E_Space 的候选队论文，我们建出广义串并联图进行「删一度点」「缩二度点」「叠合重边」操作合并信息的表达式树。
我们把其描述成一颗 Leafy Tree。
我们不妨在每个叶节点处存一个点或者边，非叶节点处存一个算符 $op$。
每个非叶节点将根据其合并方式来决定其究竟表示一个点，还是表示一个边。
对于表示边的节点，我们可以用一个四维向量 $(A,B,C,D)&amp;rsquo;$ 描述之，表示左右点分别取 $0/1$ 状态所对应的权值；注意左右不可交换。
对于表示点的节点，我们可以用一个二维向量 $(b,w)&amp;rsquo;$ 描述之（或者直接拓宽成 $(b,w,-\infty,-\infty)&amp;rsquo;$ 四维向量），表示其取两种方案是分别最大权。
合并操作不妨分为四种：「删一度点」「缩二度点」「叠合重边」「边序翻转」。
其中「边序翻转」操作用于把 $(u,v)$ 当作 $(v,u)$ 处理的情境。
建树过程可以通过 bfs 当前点类型实现。
对于四种操作，我们分别计算合并方式。
对当前 $f,p,e=(f,p)$ 进行「删一度点」操作，其将合并为 $f$。
$$\begin{pmatrix}b_f\w_f\end{pmatrix}\leftarrow\begin{pmatrix}\max{b_f+b_p+A_e,b_f+w_p+B_e}\\max{w_f+b_p+C_e,w_f+w_p+D_e}\end{pmatrix}$$
对当前 $p,e_1=(u,p),e_2=(p,v)$ 进行「缩二度点」操作，其将合并为 $e=(u,v)$。
$$\begin{pmatrix}A_e\B_e\C_e\D_e\end{pmatrix}\leftarrow\begin{pmatrix}\max{A_{e_1}+b_p+A_{e_2},B_{e_1}+w_p+C_{e_2}}\\max{A_{e_1}+b_p+B_{e_2},B_{e_1}+w_p+D_{e_2}}\\max{C_{e_1}+b_p+A_{e_2},D_{e_1}+w_p+C_{e_2}}\\max{C_{e_1}+b_p+B_{e_2},D_{e_1}+w_p+D_{e_2}}\end{pmatrix}$$
对当前 $e_1=(u,v),e_2=(u,v)$ 进行「叠合重边」操作，其将合并为 $e=(u,v)$。
$$\begin{pmatrix}A_e\B_e\C_e\D_e\end{pmatrix}\leftarrow\begin{pmatrix}A_{e_1}+A_{e_2}\B_{e_1}+B_{e_2}\C_{e_1}+C_{e_2}\D_{e_1}+D_{e_2}\end{pmatrix}$$
对当前 $e=(v,u)$ 进行「边序翻转」操作，其将变为 $e=(u,v)$。
$$\begin{pmatrix}A_e\B_e\C_e\D_e\end{pmatrix}\leftarrow\begin{pmatrix}A_e\C_e\B_e\D_e\end{pmatrix}$$
使用树剖，每次在矩阵中记录轻儿子的信息，进行重链信息合并，向链顶父亲传递信息。
容易构造转移矩阵。
这样子朴素实现单组询问是 $O(\log^2n)$ 的，使用 GBT 等可以做到 $O(\log n)$。
代码实现
。</content></entry><entry><title>USACO2023Feb 游记</title><url>/post/usaco2023feb/</url><categories><category>游记</category></categories><tags><tag>游记</tag><tag>题解</tag><tag>做题记录</tag></tags><content type="html"><![CDATA[  由于学校要求，过来打 USACO。
由于上次已经打到白金了，所以继续。
然后还是 AK 了。
感觉题意很迷惑，所以都翻译一下。
Hungry CowBessie 很饿，每天晚饭如果有干草就会吃 $1$ 份，没有就不吃，初始没有干草。
每天早上 Farmer John 会给它送若干干草，设第 $k$ 天送 $a_k$ 份干草，初始时 $a_k=0$，表示该天不送干草。
$q$ 次操作，每次给出 $x,y$，表示将 $a_x$ 改成 $y$，请将在此时 Bessie 有干草吃的日期编号求和并输出。对 $10^9+7$ 取模。
操作间互不独立。
$1\le q\le10^5$，$1\le x\le10^{14}$，$0\le y\le10^9$。
注意到这个过程是一个“前时间”对“后时间”的贡献，考虑兔队线段树。
维护区间内有干草吃的编号数 $cnt$、编号和 $ans$，以及对区间外的贡献 $more$。
单点修改，全局查询。
考虑计算左侧区间对当前节点带来 $c$ 的前缀贡献时，区间内三个值的值。
当填满左儿子空位时，就不用向左递归；否则，只用向左递归，右儿子结果和 $c=0$ 时的右儿子结果一致。
总复杂度 $O(q\log^2v)$。
核心代码：
1const ullt Mod=1e9+7,inv2=5e8+4; 2typedef ConstMod::mod_ullt&amp;lt;Mod&amp;gt;modint; 3typedef std::vector&amp;lt;modint&amp;gt;modvec; 4inline modint sum(ullt l,ullt r){return modint(r-l)*(l+r-1)*inv2;} 5struct Seg{ 6 Seg*L,*R;ullt id,len,cnt,more;modint ans; 7 Seg(ullt l,ullt r):L(NULL),R(NULL),id(l),len(r-l),cnt(0),more(0),ans(){} 8 voi chg(ullt p,ullt v){ 9 if(len==1){ 10 if(v)cnt=1,more=v-1,ans=id;else cnt=more=0,ans=0; 11 return; 12 } 13 if(p&amp;lt;(len&amp;gt;&amp;gt;1)){ 14 …  ]]></content></entry><entry><title>多叉分治半在线卷积</title><url>/post/multi-div-semi-relaxed-mul/</url><categories><category>学术</category></categories><tags><tag>学术</tag></tags><content type="html"><![CDATA[  唔，把以前一直口胡着的多叉分治半在线卷积实现了一下啊！
这个算法的思想是，我们分治计算贡献时，设目前区间长度为 $n$，分成 $B$ 个部分，并且用 cdq 的方式计算贡献，其中 $B$ 是关于 $n$ 的一个函数。
考虑平常 $B=2$ 时最优，是因为计算两两支之间的贡献均为 $O(n/B\log (n/B))$ 的，也即要进行 $B^2$ 轮长度为 $n/B$ 的 FFT，多叉没有优化效果。
此时，我们注意到转移时的乘法中本质不同的 poly 只有 $O(B)$ 个，我们可以提前 DFT 算出各个多项式的点值，每次把点值对应做贡献，最后分别一轮 IDFT 插值计算即可。这样只用做大约 $3B-3$ 轮长度为 $2n/B$ 的 FFT（使用循环卷积！），以及计算点值间乘法贡献的 $\Theta(B^2)$ 对。
从而单层的复杂度为 $\Theta(nB+n\log(n/B))$，取 $B=\log n$，即得单层复杂度为 $\Theta(n\log n)$ 的。
可以证明递归层数是 $\Theta(\log n/\log\log n)$ 级别的，总复杂度即为 $\Theta(n\log^2n/\log\log n)$。
按照 EI 论文，目前理论界存在一个神秘的 $O(n\log^{1+\epsilon}n)$ 的半在线卷积算法（$O(n\log ne^{2\sqrt{\log2\log\log n}})$），感觉估计在 OI 圈内没啥用，除了指出在线算法往往和迭代法有相近的复杂度以及更小的常数外。
总不会这个东西是对那个 $O(B^2)$ 对点值转移的过程继续调用当前算法吧？反正我是不会的。。。
2023.4.13 upd：这个东西的复杂度是 $O(n\log^{\log_23}n)$ 的。另一个更优的做法可以参见 EI 博客。（似乎就是把平衡的部分又细化了一下？）
放一下不等关系的代码。
封装版：
1const ullt Mod=998244353,g=3; 2typedef ConstMod::mod_ullt&lt;Mod&gt;modint; 3typedef std::vector&lt;modint&gt;modvec; 4typedef NTT_POLY::poly_NTT&lt;Mod,g&gt;poly; 5typedef NTT_POLY::poly_eval&lt;Mod,g&gt;eval; 6typedef NTT_POLY::poly_inter&lt;Mod,g&gt;inter; 7typedef NTT_POLY::poly_cpd&lt;Mod,g&gt;cpd; 8typedef NTT_POLY::poly_nums&lt;Mod,g&gt;nums; 9typedef FWT_MODINT::FWT_Mod&lt;Mod&gt;FWT; 10modint P[200005],Q[200005],Dp[100005]; 11bol A[100005]; 12voi dfs(uint l,uint r){ 13 if(r-l&lt;=128){ 14 for(uint i=l;i&lt;r;i++){ 15 Dp[i]+=Q[i+1];if(A[i])for(uint j=1;i+j&lt;r;j++)Dp[i+j]-=Dp[i]*Q[j]; 16 } 17 return; 18 } 19 uint B=1; 20 if(r-l&lt;=256)B=32; 21 else if(r-l&lt;=512)B=64; 22 else if(r-l&lt;=1024)B=128; 23 else while(B*8&lt;r-l)B&lt;&lt;=1; 24 uint Cnt=(r-l+B-1)/B; 25 poly::DIFDIT s(B&lt;&lt;1); 26 modvec A[15],C[15]; 27 for(uint i=0;i&lt;Cnt;i++){ 28 uint L=l+i*B,R=std::min(r,l+(i+1)*B); 29 modvec User(B&lt;&lt;1); 30 for(uint j=0;j&lt;i;j++)for(uint k=0;k&lt;(B&lt;&lt;1);k++)User[k]+=A[j][k]*C[i-j-1][k]; 31 s.dit(User); 32 for(uint j=0;j&lt;R-L;j++)Dp[L+j]-=User[j+B]; 33 dfs(L,R); 34 if(i!=Cnt-1){ 35 A[i].resize(B&lt;&lt;1),C[i].resize(B&lt;&lt;1); 36 for(uint j=0;j&lt;(B&lt;&lt;1);j++)A[i][j]=Q[i*B+j]; 37 for(uint j=L;j&lt;R;j++)if(::A[j])C[i][j-L]=Dp[j]; 38 s.dif(A[i]),s.dif(C[i]); 39 } 40 } 41} 42chr C[100005]; 43int main() 44{ 45#ifdef MYEE 46 freopen(&#34;QAQ.in&#34;,&#34;r&#34;,stdin); 47 // freopen(&#34;QAQ.out&#34;,&#34;w&#34;,stdout); 48#endif 49 P[0]=1;for(uint i=1;i&lt;=100001;i++)P[i]=P[i-1]*i; 50 Q[100001]=P[100001].inv();for(uint i=100001;i;i--)Q[i-1]=Q[i]*i; 51 uint n=0;scanf(&#34;%s&#34;,C);while(C[n])n++; 52 uint cnt=0; 53 for(uint i=0;i&lt;n;i++)Dp[i]=0,A[i]=C[i]==&#39;&gt;&#39;,cnt+=A[i]; 54 dfs(0,n+1); 55 (cnt&amp;1?-Dp[n]*P[n+1]:Dp[n]*P[n+1]).println(); 56 return 0; 57} 散装版：
1const uint Mod=998244353,g=3; 2inline uint chg(uint v){return v&lt;Mod?v:v-Mod;} 3class DIFDIT 4{ 5 private: 6 uint n;uint*G; 7 public: 8 DIFDIT():n(0),G(NULL){} 9 DIFDIT(uint len) 10 { 11 n=1;while(n&lt;len)n&lt;&lt;=1; 12 G=new uint[n],G[0]=1; 13 uint w=power&lt;ullt&gt;(g,(Mod-1)/n,Mod),*End=G+n; 14 for(uint*_G=G+1;_G&lt;End;_G++)*_G=(ullt)_G[-1]*w%Mod; 15 } 16 ~DIFDIT(){if(G!=NULL)delete[]G,G=NULL;} 17 inline uint size(){return n;} 18 voi dif(std::vector&lt;uint&gt;&amp;x) 19 { 20 if(x.size()&lt;n)x.resize(n); 21 for(uint i=n&gt;&gt;1;i;i&gt;&gt;=1)for(uint j=0;j&lt;n;j+=i&lt;&lt;1) 22 { 23 uint*w=G; 24 for(uint k=0;k&lt;i;k++,w+=n/(2*i)) 25 { 26 uint u=x[j|k],t=x[i|j|k]; 27 x[j|k]=chg(u+t),x[i|j|k]=(ullt)(u+Mod-t)*(*w)%Mod; 28 } 29 } 30 } 31 voi dit(std::vector&lt;uint&gt;&amp;x) 32 { 33 if(x.size()&lt;n)x.resize(n); 34 for(uint i=1;i&lt;n;i&lt;&lt;=1)for(uint j=0;j&lt;n;j+=i&lt;&lt;1) 35 { 36 uint*w=G; 37 for(uint k=0;k&lt;i;k++,w+=n/(2*i)) 38 { 39 uint t=(ullt)x[i|j|k]*(*w)%Mod; 40 x[i|j|k]=chg(x[j|k]+Mod-t),x[j|k]=chg(x[j|k]+t); 41 } 42 } 43 for(uint i=1;i*2&lt;n;i++)std::swap(x[i],x[n-i]); 44 uint t=power&lt;ullt&gt;(n,Mod-2,Mod);for(uint i=0;i&lt;n;i++)x[i]=(ullt)x[i]*t%Mod; 45 } 46}; 47uint Q[200005],Dp[100005]; 48bol A[100005]; 49voi dfs(uint l,uint r){ 50 if(r-l&lt;=64){ 51 for(uint i=l;i&lt;r;i++){ 52 Dp[i]=chg(Dp[i]+Q[i+1]); 53 if(A[i])for(uint j=1;i+j&lt;r;j++) 54 Dp[i+j]=chg(Dp[i+j]+Mod-(ullt)Dp[i]*Q[j]%Mod); 55 } 56 return; 57 } 58 uint B=1; 59 if(r-l&lt;=128)B=16; 60 else if(r-l&lt;=256)B=32; 61 else if(r-l&lt;=512)B=64; 62 else if(r-l&lt;=1024)B=128; 63 else while(B*8&lt;r-l)B&lt;&lt;=1; 64 uint Cnt=(r-l+B-1)/B; 65 DIFDIT s(B&lt;&lt;1); 66 std::vector&lt;uint&gt;A[7],C[7]; 67 for(uint i=0;i&lt;Cnt;i++){ 68 uint L=l+i*B,R=std::min(r,l+(i+1)*B); 69 std::vector&lt;uint&gt;User(B&lt;&lt;1); 70 for(uint j=0;j&lt;i;j++)for(uint k=0;k&lt;(B&lt;&lt;1);k++) 71 User[k]=(User[k]+(ullt)A[j][k]*C[i-j-1][k])%Mod; 72 s.dit(User); 73 for(uint j=0;j&lt;R-L;j++)Dp[L+j]=chg(Dp[L+j]+Mod-User[j+B]); 74 dfs(L,R); 75 if(i!=Cnt-1){ 76 A[i].resize(B&lt;&lt;1),C[i].resize(B&lt;&lt;1); 77 for(uint j=0;j&lt;(B&lt;&lt;1);j++)A[i][j]=Q[i*B+j]; 78 for(uint j=0;j&lt;B;j++)if(::A[j+L])C[i][j]=Dp[j+L]; 79 s.dif(A[i]),s.dif(C[i]); 80 } 81 } 82} 83chr C[100005]; 84int main() 85{ 86#ifdef MYEE 87 freopen(&#34;QAQ.in&#34;,&#34;r&#34;,stdin); 88 // freopen(&#34;QAQ.out&#34;,&#34;w&#34;,stdout); 89#endif 90 uint n=0,v=1,cnt=0;scanf(&#34;%s&#34;,C);while(C[n])n++; 91 for(uint i=2;i&lt;=n+1;i++)v=(ullt)v*i%Mod; 92 Q[n+1]=power&lt;ullt&gt;(v,Mod-2,Mod); 93 for(uint i=n+1;i;i--)Q[i-1]=(ullt)Q[i]*i%Mod; 94 for(uint i=0;i&lt;n;i++)cnt+=A[i]=C[i]==&#39;&gt;&#39;; 95 dfs(0,n+1); 96 printf(&#34;%llu\n&#34;,cnt&amp;1?chg(Mod-(ullt)Dp[n]*v%Mod):(ullt)Dp[n]*v%Mod); 97 return 0; 98} 目前 loj 最优解（301ms）：链接。
Update：被 Alpha 重测无了。/kel
  ]]></content></entry><entry><title>loj2839</title><url>/post/loj2839/</url><categories><category>题解</category></categories><tags><tag>题解</tag><tag>loj</tag></tags><content type="html"><![CDATA[  除了 L 神 txdy 我还能说啥呢。（L 神把这题搬模拟赛了。。。）
即把每个 x 换成 ( 或 )，问是否能通过不多于一次区间反转（( 与 ) 交换）后合法。
考虑怎样的括号串是合法的。
假设左括号为 $a_p=0$，右括号为 $a_p=1$，标号 $0\sim n-1$。
我们设 $S_r=\sum_{k&amp;lt;r}(-1)^{a_k}$，则一个串合法当且仅当
$$S_p\ge0\land S_n=0$$
容易发现只要 ${S_k}$ 不同则不同，我们构造了一个 $S$ 和括号串的双射。（折线法！）
现在再考虑反转操作。
假设反转 $[l,r)$。
则
$$S_p\ge0\quad(p\le l)$$
$$S_l-(S_p-S_l)\ge0\quad(l&amp;lt;p\le r)$$
$$S_l-(S_r-S_l)+(S_p-S_r)\ge0\quad(r&amp;lt;p)$$
$$S_l-(S_r-S_l)+(S_n-S_r)=0$$
化简代换一下，也即
$$S_p\ge0\quad(p\le l)$$
$$S_p\le2S_l\quad(l&amp;lt;p\le r)$$
$$S_p\ge S_n\quad(r&amp;lt;p&amp;lt;n)$$
$$S_n=2(S_r-S_l)$$
考虑到直接 dp 可能会计重（合法的 $l,r$ 不唯一），考虑如何避免计重。
一般来说，避免计重可以通过对条件的贪心化实现，也即对每种方案确定某种最优的 $(l,r)$ 对。
假设 $l\sim r$ 间最大 $S$ 为 $S_{\max}$，容易发现 $S_{\max}\le2S_l$。
考虑对 $S_n$ 分类讨论。
当 $S_n&amp;gt;0$ 时，假设存在 $S_p&amp;lt;0$，取 $S_l=\lceil S_{\max}/2\rceil$ 总是不妨最优（顺带一提，$2\le S_n\le S_r=S_l+S_n/2\le S_{\max}\le2S_l$）；也即 $2S_l-1\le S_{\max}\le2S_l$。并且总是取最后一个可能的 $l$，因此下次枚举到一个 $S_p=S_l$ 时要查看 $S_l\sim S_p$ 区间内有无 $S&amp;lt;0$，倘没有则总是不得转移。可以证明这样的 $l$ 总是最优且唯一。
区间合法遇到 $r$ 时， …  ]]></content></entry><entry><title>CF207C</title><url>/post/cf207c/</url><categories><category>题解</category></categories><tags><tag>题解</tag><tag>CF</tag></tags><content type="html"><![CDATA[  前言学习 zzd 博客（
这题超级没有素质。
连个题解都搜不到。
好不容易搜到一个。
看了一下是 pascal。
不过还好我有办法。
树剖做 $k$ 级祖先。
十万的俩老哥飘过。
三百毫秒优异成绩。
哇哈哈哈哈哈哈哈。
接下来该放代码了。
做法描述在代码后。
Code这个能做到 $n_1,n_2\le300000$ 的情况。
1uint FathA[300005],FathB[300005],SA[300005],Rank[300005],tp1,tp2; 2chr C_A[300005],C_B[300005]; 3voi build(){ 4 static uint Fath[300005],Fath2[300005]; 5 uint n=tp2;for(uint i=0;i&amp;lt;n;i++)Fath[i]=FathB[i],SA[i]=i; 6 std::sort(SA,SA+n,[&amp;amp;](uint a,uint b){return C_B[a]&amp;lt;C_B[b];}); 7 for(uint i=0;i&amp;lt;n;i++)Rank[SA[i]]=i&amp;amp;&amp;amp;C_B[SA[i]]==C_B[SA[i-1]]?Rank[SA[i-1]]:i; 8 for(uint len=1;len&amp;lt;n;len&amp;lt;&amp;lt;=1){ 9 static std::pair&amp;lt;uint,uint&amp;gt;W[300005]; 10 bol ok=true; 11 for(uint i=0;i&amp;lt;n;i++){ 12 W[i]={Rank[i],~Fath[i]?Rank[Fath[i]]+1:0u}; 13 if(~Fath[i])Fath2[i]=Fath[Fath[i]],ok=false; 14 else Fath2[i]=Fath[i]; 15 } 16 for(uint i=0;i&amp;lt;n;i++)Fath[i]=Fath2[i]; 17 if(ok)break; 18 static uint Cnt[300005]; 19 for(uint i=0;i&amp;lt;=n;i++)Cnt[i]=0; 20 for(uint i=0;i&amp;lt;n;i++)Cnt[W[i].second]++; 21 for(uint …  ]]></content></entry><entry><title>loj2511</title><url>/post/loj2511/</url><categories><category>题解</category></categories><tags><tag>题解</tag><tag>loj</tag></tags><content type="html"><![CDATA[  引言思维题。
这个做法跑得飞快，还不用 dp，也不是爆搜！
复杂度（可能）为 $O(s^2t)$ 或 $O(s^2)$，实际效率也是飞快。
不过这题我直接提交答案了。
思路考虑 $A=mn,B=m+n$。
假设 $A$ 先手。
从 $A$ 中枚举分解方案，假设有 $(m_1,n_1)(m_2,n_2)\cdots(m_k,n_k)$ 这些合法。
如 $k&amp;gt;1$，会说不知道，称这样的 $A$ 构成集合 $A_{&amp;gt;0}$；否则知道，称这样的 $A$ 构成集合 $A_0$。
对 $B$ 分解，其有 $(s,B-s)(s+1,B-s-1)\cdots(\lfloor B/2\rfloor,\lceil B/2\rceil)$ 这些合法。
从中选出相乘为 $A_0$ 中元素的数对，若唯一，记这样的 $B$ 构成 $B_0&amp;rsquo;$，说明知道；若多于 $1$ 个，则无法计算；若不存在，若解集大小为 $1$，则构成集合 $B_0$，说明知道；若解集大小大于 $1$，构成集合 $B_{&amp;gt;0}$。
对 $B_0$ 集合类似地反推 $A_1&amp;rsquo;$，对 $B_{&amp;gt;0}$ 反推出 $A_1,A_{&amp;gt;1}$。
刚才的描述不够清晰，让我们形式化地说：
$$ \def\defeq{\mathop{=}\limits^{\operatorname{def}}} \begin{array}{|l|} \hline X(A)\defeq{(m,n)|s\le m\le n,mn=A}\newline Y(B)\defeq{(m,n)|s\le m\le n,m+n=B}\newline A_{\ge0}\defeq{A|X(A)\neq\varnothing}\newline B_{\ge0}\defeq{B|Y(B)\neq\varnothing}\newline\hdashline A_0\defeq{A|A\in A_{\ge0},|X(A)|=1}\newline A_{\ge1}\defeq A_{\ge0}-A_0\newline\hdashline X_0\defeq\cup_{A\in A_0}X(A)\newline B_0&amp;rsquo;\defeq{B|B\in B_{\ge0},|Y(B)\cap X_0|=1}\newline …  ]]></content></entry><entry><title>ABC268 VP记</title><url>/post/abc268/</url><categories><category>游记</category></categories><tags><tag>游记</tag><tag>题解</tag><tag>做题记录</tag></tags><content type="html"><![CDATA[  引言几天没比赛，手痒了，决定尝试 VP 一场 ABC，作为第一次 VP AT（
下次可能就不挑这么简单的场了（
VP 登顶留念。
比赛从 19:30 开始。我一路正开，也没啥罚时。
比赛题解A憨憨题。直接 sort + unique 即可。
1std::vector&lt;uint&gt;A(5); 2for(auto&amp;v:A)scanf(&#34;%u&#34;,&amp;v); 3std::sort(A.begin(),A.end()); 4printf(&#34;%d\n&#34;,(int)(std::unique(A.begin(),A.end())-A.begin())); B憨憨题。直接做即可。
1chr C1[205],C2[205]; 2scanf(&#34;%s%s&#34;,C1,C2); 3uint n=0; 4while(C1[n]){ 5 if(C1[n]!=C2[n])return puts(&#34;No&#34;),0; 6 n++; 7} 8puts(&#34;Yes&#34;); C憨憨题。随便计算一下差量即可。
1uint A[200005]; 2uint n;scanf(&#34;%u&#34;,&amp;n); 3for(uint i=0,v;i&lt;n;i++)scanf(&#34;%u&#34;,&amp;v) ,A[(i+n-v)%n]++; 4uint ans=0; 5for(uint i=0;i&lt;n;i++)_max(ans,A[i]+A[(i+1)%n]+A[(i+2)%n]); 6printf(&#34;%u\n&#34;,ans); D暴力 dfs 即可。
状态数可以预见不会很多。
细节有亿点多。
1typedef std::vector&lt;chr&gt;str; 2std::set&lt;str&gt;S;str C[32],now;chr User[32];uint n;bol Used[32]; 3voi dfs(uint p){ 4 if(now.size()&gt;16)return; 5 if(p==n){ 6 for(uint i=0;i&lt;n;i++)if(!Used[i]){ 7 now.insert(now.end(),C[i].begin(),C[i].end()); 8 if(now.size()&gt;=3&amp;&amp;now.size()&lt;=16&amp;&amp;!S.count(now)){ 9 for(auto s:now)putchar(s); 10 exit(0); 11 } 12 now.erase(now.end()-C[i].size(),now.end()); 13 } 14 return; 15 } 16 uint lim=18-now.size(); 17 for(uint i=0;i&lt;n;i++)if(!Used[i])lim-=C[i].size()+1; 18 for(uint i=0;i&lt;n;i++)if(!Used[i]){ 19 Used[i]=1,now.insert(now.end(),C[i].begin(),C[i].end()); 20 for(uint k=1;k&lt;=lim;k++) 21 { 22 for(uint t=1;t&lt;=k;t++)now.push_back(&#39;_&#39;); 23 dfs(p+1); 24 now.erase(now.end()-k,now.end()); 25 } 26 now.erase(now.end()-C[i].size(),now.end()),Used[i]=0; 27 } 28} 29int main() 30{ 31#ifdef MYEE 32 freopen(&#34;QAQ.in&#34;,&#34;r&#34;,stdin); 33 // freopen(&#34;QAQ.out&#34;,&#34;w&#34;,stdout); 34#endif 35 uint m;scanf(&#34;%u%u&#34;,&amp;n,&amp;m); 36 for(uint i=0;i&lt;n;i++){ 37 scanf(&#34;%s&#34;,User); 38 for(chr c:User)if(c)C[i].push_back(c);else break; 39 } 40 while(m--){ 41 scanf(&#34;%s&#34;,User); 42 for(chr c:User)if(c)now.push_back(c);else break; 43 S.insert(now),now.clear(); 44 } 45 dfs(1); 46 puts(&#34;-1&#34;); 47 return 0; 48} E还是考虑计算差量。
反向考虑对每种旋转方案的贡献，然后就是区间加一次函数。
直接用差分维护一下即可。
细节有亿点多。
1ullt A[200005],B[200005];uint n; 2voi add_base(ullt*A,uint l,uint r,ullt v){A[r]-=v,A[l]+=v;} 3voi add(uint l,uint r,ullt k,ullt b){add_base(A,l,r,k),add_base(B,l,r,b);} 4voi add_all(int l,int r,ullt k,ullt b){ 5 if(l&lt;0) 6 { 7 add(l+n,n,k,b-n*k),add(0,r,k,b); 8 return; 9 } 10 if(r&gt;(int)n){ 11 add(l,n,k,b),add(0,r-n,k,b+k*n); 12 return; 13 } 14 add(l,r,k,b); 15} 16int main() 17{ 18#ifdef MYEE 19 freopen(&#34;QAQ.in&#34;,&#34;r&#34;,stdin); 20 // freopen(&#34;QAQ.out&#34;,&#34;w&#34;,stdout); 21#endif 22 scanf(&#34;%u&#34;,&amp;n); 23 for(uint i=0,v;i&lt;n;i++){ 24 scanf(&#34;%u&#34;,&amp;v),v=(v+n-i)%n; 25 add_all(v-n/2,v,-1llu,v); 26 add_all(v,v+n-n/2,1llu,-(ullt)v); 27 } 28 for(uint i=0;i&lt;n;i++)A[i+1]+=A[i],B[i+1]+=B[i]; 29 ullt ans=-1; 30 for(uint i=0;i&lt;n;i++)_min(ans,A[i]*i+B[i]); 31 printf(&#34;%llu\n&#34;,ans); 32 return 0; 33} F国王游戏的经典调整法贪心。
1typedef std::pair&lt;ullt,ullt&gt;Pair; 2chr C[200005];Pair P[200005]; 3uint n;ullt ans=0;scanf(&#34;%u&#34;,&amp;n); 4for(uint i=0;i&lt;n;i++){ 5 scanf(&#34;%s&#34;,C); 6 for(chr c:C)if(c){ 7 if(c&lt;=&#39;9&#39;)ans+=P[i].first*(c-&#39;0&#39;),P[i].second+=c-&#39;0&#39;; 8 else P[i].first++; 9 }else break; 10} 11std::sort(P,P+n,[&amp;](Pair a,Pair b){ 12 return a.first*b.second&gt;a.second*b.first; 13}); 14ullt s=0; 15for(uint i=0;i&lt;n;i++)ans+=s*P[i].second,s+=P[i].first; 16printf(&#34;%llu\n&#34;,ans); G考虑对排名反向计算贡献。
对 $i$ 在 $j$ 前的概率，有以下几种状态：
$s_i$ 为 $s_j$ 前缀，则 $i$ 必然在 $j$ 前。 $s_j$ 为 $s_i$ 前缀，则 $i$ 必然在 $j$ 后。 其余情况，前后顺序等可能出现。 直接拿棵 Trie 计算一下每个串有几个前缀出现在全集中，及作为全集中多少串的前缀。
然后随便统计一下信息就完了。
1const ullt Mod=998244353; 2typedef ConstMod::mod_ullt&lt;Mod&gt;modint; 3struct node{node*son[26];uint v1,v2;}N[2000005],*rot=N,*cnt=N+1; 4node*NewNode(){return cnt++;} 5#define Id(p) ((uint)((p)-N)) 6#define Turn(c) ((c)-&#39;a&#39;) 7node*insert(chr*C){ 8 node*p=N; 9 while(*C){ 10 p-&gt;v1++;auto&amp;s=p-&gt;son[Turn(*(C++))]; 11 if(!s)s=NewNode(); 12 p=s; 13 } 14 p-&gt;v2++; 15 return p; 16} 17chr C[500005]; 18node*At[500005]; 19int main() 20{ 21#ifdef MYEE 22 freopen(&#34;QAQ.in&#34;,&#34;r&#34;,stdin); 23 // freopen(&#34;QAQ.out&#34;,&#34;w&#34;,stdout); 24#endif 25 uint n;scanf(&#34;%u&#34;,&amp;n); 26 for(uint i=0;i&lt;n;i++)scanf(&#34;%s&#34;,C),At[i]=insert(C); 27 for(node*p=rot;p!=cnt;p++)for(auto s:p-&gt;son)if(s)s-&gt;v2+=p-&gt;v2; 28 for(uint i=0;i&lt;n;i++){ 29 (modint(n-At[i]-&gt;v1+At[i]-&gt;v2)/2).println(); 30 } 31 return 0; 32} H考虑对文本串每个前缀，计算出其最短的存在于模板串中的后缀。
这个拿个 ACAM 即可搞定。
然后就是每个这样的区间都得删掉一个点，直接贪心 / 差分约束即可。
1const uint sigma=26; 2struct node{node*son[sigma],*fail;uint kill;node():kill(-1u){}}N[2000005],*rot=N,*cnt=N+1; 3node*NewNode(){return cnt++;} 4#define Id(p) ((uint)((p)-N)) 5#define Turn(c) ((c)-&#39;a&#39;) 6voi insert(chr*C){ 7 node*p=N;uint len=0; 8 while(*C){ 9 auto&amp;s=p-&gt;son[Turn(*(C++))]; 10 if(!s)s=NewNode(); 11 p=s,len++; 12 } 13 _min(p-&gt;kill,len); 14} 15voi build(){ 16 std::queue&lt;node*&gt;Q;rot-&gt;fail=rot; 17 for(uint i=0;i&lt;sigma;i++)(rot-&gt;son[i]?(Q.push(rot-&gt;son[i]),rot-&gt;son[i]-&gt;fail):rot-&gt;son[i])=rot; 18 while(!Q.empty()){ 19 node*p=Q.front();Q.pop(),_min(p-&gt;kill,p-&gt;fail-&gt;kill); 20 for(uint i=0;i&lt;sigma;i++) 21 (p-&gt;son[i]?(Q.push(p-&gt;son[i]),p-&gt;son[i]-&gt;fail):p-&gt;son[i])=p-&gt;fail-&gt;son[i]; 22 } 23} 24chr S[500005],C[500005]; 25int main() 26{ 27#ifdef MYEE 28 freopen(&#34;QAQ.in&#34;,&#34;r&#34;,stdin); 29 // freopen(&#34;QAQ.out&#34;,&#34;w&#34;,stdout); 30#endif 31 scanf(&#34;%s&#34;,S); 32 uint n;scanf(&#34;%u&#34;,&amp;n); 33 while(n--){ 34 scanf(&#34;%s&#34;,C); 35 insert(C); 36 } 37 build(); 38 uint ans=0,last=1e9; 39 node*p=rot; 40 for(auto c:S)if(c){ 41 last++,p=p-&gt;son[Turn(c)]; 42 if(last&gt;=p-&gt;kill) 43 last=0,ans++; 44 }else break; 45 printf(&#34;%u\n&#34;,ans); 46 return 0; 47}   ]]></content></entry><entry><title>USACO2023Jan 游记</title><url>/post/usaco2023jan/</url><categories><category>游记</category></categories><tags><tag>游记</tag><tag>题解</tag><tag>做题记录</tag></tags><content type="html"><![CDATA[  由于学校要求，过来打 USACO。
似乎要求起码升到白金？
由于是第一次打，只有从铜组开始了。
Brouze简单题，就给核心代码。
30min AK。
Leadershttp://usaco.org/current/index.php?page=viewproblem2&amp;cpid=12751chr C[100005];uint R[100005]; 2int main() 3{ 4#ifdef MYEE 5 freopen(&amp;#34;QAQ.in&amp;#34;,&amp;#34;r&amp;#34;,stdin); 6 // freopen(&amp;#34;QAQ.out&amp;#34;,&amp;#34;w&amp;#34;,stdout); 7#endif 8 uint n;scanf(&amp;#34;%u%s&amp;#34;,&amp;amp;n,C);for(uint i=0;i&amp;lt;n;i++)scanf(&amp;#34;%u&amp;#34;,R+i); 9 chr c=*C;uint p=0;while(C[p]==c)p++; 10 uint ans=0;for(uint i=0;i&amp;lt;p;i++)ans+=R[i]&amp;gt;p; 11 bol ok=R[0]==p;for(uint i=p;i&amp;lt;n;i++)ok&amp;amp;=C[i]!=c; 12 ans+=ok; 13 printf(&amp;#34;%u\n&amp;#34;,ans); 14 return 0; 15} Air Cownditioning IIhttp://usaco.org/current/index.php?page=viewproblem2&amp;cpid=12761uint L[25],R[25],C[25],A[25],B[25],P[25],M[25],Cnt[105]; 2int main() 3{ 4#ifdef MYEE 5 freopen(&amp;#34;QAQ.in&amp;#34;,&amp;#34;r&amp;#34;,stdin); 6 // freopen(&amp;#34;QAQ.out&amp;#34;,&amp;#34;w&amp;#34;,stdout); 7#endif 8 uint n,m;scanf(&amp;#34;%u%u&amp;#34;,&amp;amp;n,&amp;amp;m); 9 for(uint …  ]]></content></entry><entry><title>WC2023 游记</title><url>/post/wc2023/</url><categories><category>游记</category></categories><tags><tag>游记</tag><tag>图片挂了</tag></tags><content type="html"><![CDATA[  不是很会写游记，随便写写吧。
博客园内链导致大量图片挂了警告。
一些附件讲课资料合集（压缩后 $\rm 31MB$）太大了，可以去 U 群下载。
由于后面很多乐子，我把相关内容打包成 zip 上传上来了。
乐子合集下载链接。（这个包挺小方便下载）
前言：WC2022 测试怎么说呢，糟糕的回忆。
T2 我码了个压位 Trie 莫队，按理是应该过了的，但是我快写写挂了。
场上写法：
1inline voi write(uint v) 2{ 3	static chr c[18];uint cnt=0; 4 do c[cnt++]=v%10,v/=10;while(v); 5	while(cnt--)putchar(c[cnt]); 6	putchar(&amp;#39;\n&amp;#39;); 7} 正确写法：
1inline voi write(ullt v) 2{ 3	static chr c[18];uint cnt=0; 4 do c[cnt++]=v%10+&amp;#39;0&amp;#39;,v/=10;while(v); 5	while(cnt--)putchar(c[cnt]); 6	putchar(&amp;#39;\n&amp;#39;); 7} 于是直接挂没了。
T3 没加头文件，也爆蛋了。
总之就是，出场 $25+100+65$，实际 $10+0+0$。（众所周知 T1 部分分数据挂了）
但是我帮几个同学拿了 Ag。
以下开始 WC2023 正番。
前几天主要记录乐子，课件回头会发上来。
Day 0开幕式。分蛋糕。/se
乐子 dzd 没关麦/摄像头，被截图了。 图就不放上来了。
——孩子几岁了？ ——一岁半，两岁不到。
Day 1上午没啥意思，没听。
下午听了 hhz 的题目选讲，罚坐。
晚上员交，直接爆炸。
然后是一些乐子。
乐子 嗯，暴戾语言复现。
草，别让他们放PV了，把题目留着就行了。 警告一次，教室再出现不文明用语，全部踢出去，你们代表的是自己学校的形象。 PV 是咋样的呢？ CCF，以推动计算技术领域学术，技术，教育，应用和产业的发展，助力计算技术领域专业人士能力提升为使命，目前拥有超过10万名付费个人会员。 CCF，下设城市会员活动中心，学生分会，YOCSEF城市论坛，以及大数据，自然语言处理，和高性能计算等专业委员会。共近两百个会员服务机构，每年举办近千场专业活 …  ]]></content></entry><entry><title>Dinic的几种复杂度</title><url>/post/dinic-complexity/</url><categories><category>学术</category></categories><tags><tag>学术</tag></tags><content type="html"> 学了那么久网络流才发现自己不知道 Dinic 算法的一个在各边容量均为 $1$ 的网络时复杂度上的结论。我说为啥学术社区那题优化建图复杂度是对的呢……
以下均认为使用了当前弧优化与多路增广。
以下认为 $n$ 为点数，$m$ 为边数，$n=O(m)$。
以下考虑的复杂度均为 $O(\text{增广轮数}\times\text{单轮增广复杂度})$，这个显然是一个合法上界。
一般网络：$O(n^2m)$
对于一般网络，增广轮数显然为 $O(n)$，因为每轮终点层数递增。
对于单轮增广复杂度，在不限制容量范围时，不会超过 $O(nm)$：对于每个状态的当前弧，只会消耗 $O(n)$ 的时间找到一组合法增广路；而当前弧状态数不会超过 $O(m)$。
因此，对于一般网络，其复杂度为 $O(n^2m)$。
关于值域的增广轮数上界：$O(\sqrt{\sum_p\min{d^{in}_p,d^{out}_p}})$
假设每个点 $p$ 的出边容量和为 $d^{out}_p$，入边容量和为 $d^{in}_p$，定义
$$S=\sum_p\min{d^{in}_p,d^{out}_p}$$
则增广轮数不会超过 $\sqrt S$。
如果在 $\sqrt S$ 轮内已经结束，显然就是 $O(\sqrt S)$ 的。
假设已经经过了 $\sqrt S$ 轮，则到达汇点的增广路长度，也即在残量网络上的最短路长度，接下来不会低于 $\sqrt S$。
假设接下来几轮中我们还要流 $d$ 条增广路，则由于除源汇外每个点最多属于 $\min{d^{in}_p,d^{out}_p}$ 条有流量的路径，在当前残量网络中存在一种取 $d$ 条路径（不是增广路）的方案。于是残量网络上起点到终点最短路为 $O(\frac Sd)$ 的。
于是，$d=O(\sqrt S)$，所以最多再流 $O(\sqrt S)$ 轮，增广轮数即为 $O(\sqrt S)$ 的。
因此增广轮数是 $O(\sqrt S)$ 的。
各边容量均为 $1$ 的网络：$O(m\min{m^{\frac12},n^{\frac23}})$
接下来我们考虑的是各边容量均为 $1$ 的网络。
对于单轮增广复杂度，考虑到每条边会被访问不超过一次，单轮复杂度为 $O(m)$ 的。
增广轮数是 $O(\sqrt m)$ 的：$S=O(m)$。 …</content></entry><entry><title>CSP2022 游记</title><url>/post/csp2022/</url><categories><category>游记</category></categories><tags><tag>游记</tag></tags><content type="html"><![CDATA[  我还是写一下吧……
Day -1模拟赛。
成为机房垫底人。
Day 0上午补昨天模拟赛 T4。
下午补昨天模拟赛 T4。
晚上补昨天模拟赛 T4。
补完了后把昨天胡了没写的 APIO2014 连珠线写了。挺有意思的反悔贪心树形 dp 技巧。
然后回家了。
Day 1上午因为只去提高组，所以在家里 VP 了 CSP-S2021 的 T1-3。
为了适应考场没有代码补全、语法高亮之类的东西，赶紧把插件关了写。（flag）
T1，T3 半小时写完，T2 花了大概 1h 就写掉了。
11:00 起身去文渊，好坐校车去考点。
遇到了好多同学。/se
下午12:30 校车出发。
大约 13:30 的样子抵达杭师大。
在里面面到了 djwj233。/se
devin 没来。/kel
14:00 左右进了机房。
那边的工作人员说话声好大啊。/yun
14:25 解压密码发下来，给的是 Belief2022，结果实际上是 belief2022？？？
我想，这实在是无法可想了。
开题。
先看 T1T2.
T1 大概先 bfs 一轮找到每个点距离那些点不超过 $k$？然后枚举似乎可以 meet in the middle？
T2 似乎随便分类讨论一下 rmq 就完了。
14:30 能开写了，先敲一个码头。以 T2 为例。（原来考场 VS Code 是有代码补全和语法高亮哒？）
1// with code highlight and code completion, I&amp;#39;d fly. 2 3#include &amp;lt;algorithm&amp;gt; 4#include &amp;lt;stdio.h&amp;gt; 5#include &amp;lt;vector&amp;gt; 6typedef unsigned uint; 7typedef unsigned long long ullt;typedef long long llt; 8typedef bool bol;typedef char chr;typedef void voi; 9typedef double dbl; 10template&amp;lt;typename T&amp;gt;bol _min(T&amp;amp;a,T b){return b&amp;lt;a?(a=b,true):false;} 11template&amp;lt;typename …  ]]></content></entry><entry><title>挂分记录</title><url>/post/losing-score/</url><categories><category>杂项</category></categories><tags><tag>做题记录</tag></tags><content type="html"><![CDATA[  记录各种考场犯浑现象。
20221019线段树。
正确写法：Seg(uint n):len(n),siz(0),L(NULL),R(NULL),v(0),tag(1){if(n&amp;gt;1)L=new Seg(n&amp;gt;&amp;gt;1),R=new Seg(n-(n&amp;gt;&amp;gt;1));}
错误写法：Seg(uint n):len(n),siz(0),L(NULL),R(NULL),v(0),tag(1){if(n&amp;gt;1)L=new Seg(n&amp;gt;&amp;gt;1),R=new Seg(n&amp;gt;&amp;gt;1);}
结果：$100\rightarrow20$。
20221021树上倍增。
没写 a=Fath[i][a]。
结果：$100\rightarrow0$。
20221022点分治。
错误写法：
1voi get(uint p,uint f,uint v){ 2 cnt[v]++; 3 for(auto q:Qid[p])if(p==V[q]){ 4 for(uint i=0;i&amp;lt;m;i++)Ans[q]+=Qcnt[q][(W[q]+m-i)%m]*cnt[i]; 5 } 6 Qid[p].clear(); 7 for(auto s:Way[p])if(!Gone[s.first]&amp;amp;&amp;amp;s.first!=f)insert(s.first,p,(v+s.second)%m); 8 cnt[v]--; 9} 正确写法：
1voi get(uint p,uint f,uint v){ 2 cnt[v]++; 3 for(auto q:Qid[p])if(p==V[q]){ 4 for(uint i=0;i&amp;lt;m;i++)Ans[q]+=Qcnt[q][(W[q]+m-i)%m]*cnt[i]; 5 } 6 Qid[p].clear(); 7 for(auto s:Way[p])if(!Gone[s.first]&amp;amp;&amp;amp;s.first!=f)get(s.first,p,(v+s.second)%m); 8 cnt[v]--; 9} 结果：过了小样例，没过大样例，调试了 $2h$，没挂分。
20221023伯努利数自然幂和。
数据范围 $5000$。
错误写法：
1modint P[5005],Q[5005],B[5005]; …  ]]></content></entry><entry><title>HDU 多校 2022 游记</title><url>/post/hdu2022/</url><categories><category>游记</category></categories><tags><tag>游记</tag></tags><content type="html"> 在 XJ 501 机房打。
队伍：
team1093 学军中学二队
为什么有二队而没有一队，这是一个问题。
Day 1
我们原来是打算九个人打。
因为今天隔壁机房的人搬迁过来，机房里充满了快活的气息。
因为隔壁机房的人加入进来，机房里感觉有十几个人在打。
感觉非常 exciting 啊！
由于 12:00 - 17:00 比赛，提前去吃饭了。
回来时已经是 11:50 了。
EricQian：myee，那你比赛先开中间的？
myee：好。
我开场就开 G 题（一共 $12$ 题），我超勇的！
我看到的
题
意简述：
给你一张图，每个点有颜色和权值，边有权值。
一个人能通过一条边当且仅当其实力不小于边权。
他可以从每种颜色的点中挑一个他可以从起点到达的点，获得其权值的贡献。
现在有两种操作。
其一，把某个点点权增加一个正值。
其二，查询某个实力的人从某起点出发所得的最大奖赏。
数据范围均为 $10^5$，时限 $4s$，多测（$5$ 组）
我一看到就知道是 Kruskal 重构树，很快啊！
用 Dfn 转化一下，就变成了单点点权加，区间查询颜色最大权之和。
然后想都不用想，肯定是根号做法啊对不对对不对?
&amp;amp;hellip;
代码写了 $9Kb$，包括 Kruskal 重构树、由乃救爷爷式 RMQ、根号分治、二维分块、$n^{\frac13}$ 叉树等等，复杂度 $O(n\sqrt{n\log n})$，成功贡献了 $13$ 发罚时，我觉得很下饭啊！
大家好啊，我是 $13$ 发罚时老哥 myee 啊，我来给大家直播下饭！
然后后来看到 sjy 过了这题，很快啊！
我打开一看：
我敲，这怎么这么搞的？？？
PolyLog 做法？？？没有设块长！！！
后来听神 SegmentTree 说，这题是虚树可以做的。
而且我还漏掉了一个重要条件——每种颜色最多出现 $10$ 次！（根号分治、${}^3!!\sqrt n$ 叉树白写了）
sjy 打的神仙单 log 做法依赖于此。
SegmentTree 说他有一个不依赖于此的 2log 做法，我觉得很厉害啊！
队伍总排名第二十。
大佬带我飞！
Time Problem ACer(Luogu ID) 12:03 K rwalxfhg 12:09 L rwalxfhg 12:15 C realMatrixCascade 12:58 B …</content></entry><entry><title>ZJOI2022 游记</title><url>/post/zjoi2022/</url><categories><category>游记</category></categories><tags><tag>游记</tag></tags><content type="html"> 由于 devin 说比赛结束前不能复盘，先咕着。
考好后由于要文化课，还得继续咕。
2022.5.3 记
upd：喜报，2023 年省选完了我还在鸽！
基本上是咕了。
都垫底了还有啥好写的啊。
2023.4.6 记
突然发现 ZJOI2022 出题人真是 cjb
。/fad
2023.4.8 记</content></entry><entry><title>行列式入门</title><url>/post/what-is-det/</url><categories><category>学术</category></categories><tags><tag>学术</tag></tags><content type="html"><![CDATA[  前言其实是惊奇地发现班上居然有一堆人还不知道行列式是什么……
然后为了方便其查阅，我把一堆东西整一块了。
主要讲一下定义、性质啥的，顺带写几种手算求法以及相关定理。
参考资料《高等代数（第二版）上册》（丘维声著） 高代上册着重讲解线性代数，其中第二章讲述行列式。
定义我们记 $1\sim n$ 的一个排列为 $p_1p_2p_3\cdots p_n$。
我们记 $\sigma(p_1p_2p_3\cdots p_n)=\sum_{1\le i&amp;lt;j\le n}[p_i&amp;gt;p_j]$，即排列 $p_1p_2p_3\cdots p_n$ 的逆序对数。
对一个方阵 $A=(a_{ij})$，我们称 $|A|$ 或 $\det A$ 为其行列式，其值为：
$$|A|=\sum_{p_1p_2p_3\cdots p_n}(-1)^{\sigma(p_1p_2p_3\cdots p_n)}\prod_ia_{ip_i}$$
例如，矩阵 $\begin{bmatrix}1&amp;amp;2\newline 3&amp;amp;4\end{bmatrix}$ 的行列式记为 $\begin{vmatrix}1&amp;amp;2\newline 3&amp;amp;4\end{vmatrix}$，值为 $-2$。
这是定义式，也称完全展开式。
由于此矩阵是 $n\times n$ 的，即 $n$ 阶矩阵，所以此行列式被称为 $n$ 阶行列式，$n$ 称为此行列式的阶数。
似乎有的教材把按第一行展开作为定义。
性质以下不加证明地给出其七条性质。
具体证明可以使用完全展开式。
性质 $1$行列式行列互换，值不变。
写成公式即：
$$|A^T|=|A|$$
$A^T$ 表示矩阵 $A$ 的转置。
即，行列式的行、列地位相同。
以下仅写行，不作说明的话在列上也是对的。
性质 $2$把其中一行对应乘 $k$，行列式值乘上 $k$。
性质 $3$交换两行，行列式反号。
性质 $4$把一行的 $k$ 倍对应加到另一行上，行列式不变。
以上三条（$2,3,4$）导出了计算行列式的一种基本方法，即初等行变换转成上对角阵。
这三条依次对应于三类初等行变换。
性质 $5$两行对应相等，行列式值为 $0$。
性质 $6$两行对应成比例，行列式值为 $0$。
性质 $7$若把一个行列式的一行拆成两行的和，则原 …  ]]></content></entry></search>