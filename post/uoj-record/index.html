<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.118.2"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.png><link rel=icon type=image/x-icon href=/imgs/icons/favicon.png><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/favicon.png><meta itemprop=name content="UOJ随做"><meta itemprop=description content="QwQ"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://myeeye.github.io/imgs/myee_komari.png"><meta itemprop=keywords content="题解,做题记录"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.7a8fc2f048a9a1f73e4007207273268b75305a9c5710fd1fead4a1e33219fa26.css><style type=text/css>.post-footer hr:after,.flinks-list-footer hr:after{content:"~ QwQ ~"}</style><link rel=stylesheet type=text/css href=/css/custom_style.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"uoj-record","permalink":"https://myeeye.github.io/post/uoj-record/","title":"UOJ随做","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://npm.elemecdn.com/penndu@1.0.0/bsz.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>UOJ随做 - myee's blog</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>myee's blog</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>And in that light...</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>40</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/ class=hvr-icon-pulse rel=section><i class="fa fa-tag hvr-icon"></i>标签</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-flinks"><a href=/flinks.html class=hvr-icon-pulse rel=section><i class="fa fa-thumbs-up hvr-icon"></i>友情链接</a></li><li class="menu-item menu-item-random"><a href=/random.html class=hvr-icon-pulse rel=section><i class="fa fa-random hvr-icon"></i>随机页面</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#uer-1dzy-loves-graph>【UER #1】DZY Loves Graph</a></li><li><a href=#ur-1缩进优化>【UR #1】缩进优化</a></li><li><a href=#ur-1外星人>【UR #1】外星人</a></li><li><a href=#ur-2跳蚤公路>【UR #2】跳蚤公路</a></li><li><a href=#ur-2树上gcd>【UR #2】树上GCD</a></li><li><a href=#ur-3铀仓库>【UR #3】铀仓库</a></li><li><a href=#ur-3链式反应>【UR #3】链式反应</a></li><li><a href=#ur-4元旦激光炮>【UR #4】元旦激光炮</a></li><li><a href=#ur-5怎样提高智商>【UR #5】怎样提高智商</a></li><li><a href=#ur-5怎样更有力气>【UR #5】怎样更有力气</a></li><li><a href=#ur-5怎样跑得更快>【UR #5】怎样跑得更快</a></li><li><a href=#新年的巧克力棒>新年的巧克力棒</a></li><li><a href=#新年的毒瘤>新年的毒瘤</a></li><li><a href=#新年的桌游>新年的桌游</a></li><li><a href=#新年的qaq>新年的QAQ</a></li><li><a href=#ur-6破解密码>【UR #6】破解密码</a></li><li><a href=#ur-6智商锁>【UR #6】智商锁</a></li><li><a href=#ab-problem>A+B Problem</a></li><li><a href=#ur-7水题生成器>【UR #7】水题生成器</a></li><li><a href=#ur-7水题走四方>【UR #7】水题走四方</a></li><li><a href=#mx的组合数>mx的组合数</a></li><li><a href=#mx的仙人掌>mx的仙人掌</a></li><li><a href=#uer-2手机的生产>【UER #2】手机的生产</a></li><li><a href=#uer-2信息的交换>【UER #2】信息的交换</a></li><li><a href=#uer-2谣言的传播>【UER #2】谣言的传播</a></li><li><a href=#ur-8赴京赶考>【UR #8】赴京赶考</a></li><li><a href=#ur-8决战圆锥曲线>【UR #8】决战圆锥曲线</a></li><li><a href=#ur-9电路手动分析>【UR #9】电路手动分析</a></li><li><a href=#ur-9app-管理器>【UR #9】App 管理器</a></li><li><a href=#uer-3开学前的作文>【UER #3】开学前的作文</a></li><li><a href=#uer-3开学前的日历>【UER #3】开学前的日历</a></li><li><a href=#uer-3开学前的涂鸦>【UER #3】开学前的涂鸦</a></li><li><a href=#uer-4被粉碎的数字>【UER #4】被粉碎的数字</a></li><li><a href=#uer-5万圣节的南瓜灯>【UER #5】万圣节的南瓜灯</a></li><li><a href=#uer-5万圣节的数列>【UER #5】万圣节的数列</a></li><li><a href=#uer-5万圣节的糖果>【UER #5】万圣节的糖果</a></li><li><a href=#ur-10汉诺塔>【UR #10】汉诺塔</a></li><li><a href=#ur-10世界线>【UR #10】世界线</a></li><li><a href=#ur-11元旦老人与丛林>【UR #11】元旦老人与丛林</a></li><li><a href=#ur-11元旦老人与数列>【UR #11】元旦老人与数列</a></li><li><a href=#新年的破栈>新年的破栈</a></li><li><a href=#新年的网警>新年的网警</a></li><li><a href=#新年的繁荣>新年的繁荣</a></li><li><a href=#新年的腮雷>新年的腮雷</a></li><li><a href=#ur-12实验室外的攻防战>【UR #12】实验室外的攻防战</a></li><li><a href=#ur-12密码锁>【UR #12】密码锁</a></li><li><a href=#ur-12a-1--b-problem>【UR #12】a^-1 + b problem</a></li><li><a href=#ur-13yist>【UR #13】Yist</a></li><li><a href=#ur-13ernd>【UR #13】Ernd</a></li><li><a href=#ur-13sanrd>【UR #13】Sanrd</a></li><li><a href=#ur-14最强跳蚤>【UR #14】最强跳蚤</a></li><li><a href=#ur-14人类补完计划>【UR #14】人类补完计划</a></li><li><a href=#ur-14思考熊>【UR #14】思考熊</a></li><li><a href=#共价大爷游长沙>共价大爷游长沙</a></li><li><a href=#uer-6票数统计>【UER #6】票数统计</a></li><li><a href=#uer-6寻找罪犯>【UER #6】寻找罪犯</a></li><li><a href=#uer-6逃跑>【UER #6】逃跑</a></li><li><a href=#unr-1争夺圣杯>【UNR #1】争夺圣杯</a></li><li><a href=#unr-1合唱队形>【UNR #1】合唱队形</a></li><li><a href=#unr-1jakarta-skyscrapers>【UNR #1】Jakarta Skyscrapers</a></li><li><a href=#ur-15奥林匹克五子棋>【UR #15】奥林匹克五子棋</a></li><li><a href=#ur-15奥林匹克环城马拉松>【UR #15】奥林匹克环城马拉松</a></li><li><a href=#基础数据结构练习题>基础数据结构练习题</a></li><li><a href=#ur-16破坏发射台>【UR #16】破坏发射台</a></li><li><a href=#ur-16破坏蛋糕>【UR #16】破坏蛋糕</a></li><li><a href=#uer-7短路>【UER #7】短路</a></li><li><a href=#uer-7天路>【UER #7】天路</a></li><li><a href=#直径拆除鸡>直径拆除鸡</a></li><li><a href=#快乐游戏鸡>快乐游戏鸡</a></li><li><a href=#unr-2uoj拯救计划>【UNR #2】UOJ拯救计划</a></li><li><a href=#unr-2黎明前的巧克力>【UNR #2】黎明前的巧克力</a></li><li><a href=#unr-2积劳成疾>【UNR #2】积劳成疾</a></li><li><a href=#新年的xor>新年的XOR</a></li><li><a href=#新年的叶子>新年的叶子</a></li><li><a href=#ur-17滑稽树上滑稽果>【UR #17】滑稽树上滑稽果</a></li><li><a href=#unr-3鸽子固定器>【UNR #3】鸽子固定器</a></li><li><a href=#新年的拯救计划>新年的拯救计划</a></li><li><a href=#新年的小黄鸭>新年的小黄鸭</a></li><li><a href=#新年的促销>新年的促销</a></li><li><a href=#新年的追逐战>新年的追逐战</a></li><li><a href=#ur-19清扫银河>【UR #19】清扫银河</a></li><li><a href=#ur-19通用测评号>【UR #19】通用测评号</a></li><li><a href=#ur-19前进四>【UR #19】前进四</a></li><li><a href=#美团杯2020测试赛子序列>【美团杯2020测试赛】子序列</a></li><li><a href=#美团杯2020查查查乐乐>【美团杯2020】查查查乐乐</a></li><li><a href=#美团杯2020平行四边形>【美团杯2020】平行四边形</a></li><li><a href=#美团杯2020114514>【美团杯2020】114514</a></li><li><a href=#unr-4序列妙妙值>【UNR #4】序列妙妙值</a></li><li><a href=#unr-4校园闲逛>【UNR #4】校园闲逛</a></li><li><a href=#ulr-1多线程计算>【ULR #1】多线程计算</a></li><li><a href=#ulr-1服务器调度>【ULR #1】服务器调度</a></li><li><a href=#新年的密码锁>新年的密码锁</a></li><li><a href=#unr-5提问系统>【UNR #5】提问系统</a></li><li><a href=#unr-5获奖名单>【UNR #5】获奖名单</a></li><li><a href=#ur-22月球铁轨>【UR #22】月球铁轨</a></li><li><a href=#ur-23地铁规划>【UR #23】地铁规划</a></li><li><a href=#ur-23国王出游>【UR #23】国王出游</a></li><li><a href=#tba>TBA</a></li><li><a href=#tba-1>TBA</a></li><li><a href=#tba-2>TBA</a></li><li><a href=#tba-3>TBA</a></li><li><a href=#tba-4>TBA</a></li><li><a href=#tba-5>TBA</a></li><li><a href=#tba-6>TBA</a></li><li><a href=#tba-7>TBA</a></li><li><a href=#tba-8>TBA</a></li><li><a href=#tba-9>TBA</a></li><li><a href=#tba-10>TBA</a></li><li><a href=#unr-6笔试>【UNR #6】笔试</a></li></ul></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=myee src=/imgs/img-lazy-loading.gif data-src=/imgs/myee_komari.png><p class=site-author-name itemprop=name>myee</p><div class=site-description itemprop=description>QwQ</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>40</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>4</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>10</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=mailto:myeeye@qq.com title="邮箱 → mailto:myeeye@qq.com" rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>
邮箱</a></span>
<span class=links-of-social-item><a href=https://www.luogu.com.cn/user/105050 title="洛谷 → https://www.luogu.com.cn/user/105050" rel=noopener target=_blank><i class="fa fa-wifi fa-fw"></i>
洛谷</a></span>
<span class=links-of-social-item><a href=https://github.com/myeeye title="GitHub → https://github.com/myeeye" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
GitHub</a></span>
<span class=links-of-social-item><a href=https://www.zhihu.com/people/myeeye title="知乎 → https://www.zhihu.com/people/myeeye" rel=noopener target=_blank><i class="fab fa-zhihu fa-fw"></i>
知乎</a></span></div><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:var(--text-color)}</style></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=88025></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=194></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><a role=button class="book-mark-link book-mark-link-fixed"></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://myeeye.github.io/post/uoj-record/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/myee_komari.png"><meta itemprop=name content="myee"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="myee"><meta itemprop=description content="QwQ"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="UOJ随做"><meta itemprop=description content="怎么都做过 uoj Round。"></span><header class=post-header><h1 class=post-title itemprop="name headline">UOJ随做</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text title=发表于>发表于：</span>
<time title="创建时间：2023-05-06 16:12:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-05-06 16:12:00 +0800 CST">2023-05-06</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i></span>
<span class=post-meta-item-text title=更新于>更新于：</span>
<time title=修改时间：2023-10-27T16:08:00+08:00 itemprop=dateModified datetime=2023-10-27T16:08:00+08:00>2023-10-27</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text title=分类于>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E9%A2%98%E8%A7%A3 itemprop=url rel=index><span itemprop=name>题解</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span>
<span>25431</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>51分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/post/uoj-record/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>怎么都做过 uoj Round。<img src=/qqimg/kk alt=/kk class=myimg><img src=/qqimg/kk alt=/kk class=myimg><img src=/qqimg/kk alt=/kk class=myimg></p><p>只收录 UOJ 自己的题目，一些官方比赛题就算了。部分 bzoj 等处收录的题目也放上来。</p><p>没写题解不意味着没做，有的忘了写或者太草率了就算了。</p><p>部分前言删了。</p><h3 id=uer-1dzy-loves-graph>【UER #1】DZY Loves Graph
<a class=header-anchor href=#uer-1dzy-loves-graph></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>操作树一定形如一个毛毛虫。</p><p>考虑可撤销并查集维护联通块。</p><p>对于操作树上主干边暴力进行修改操作。</p><p>对于非主干边，可以只计算出答案。</p><p>加一条边可以使用并查集查询，删若干边的答案可以直接调之前某个版本的答案。</p><p>总复杂度 $O(n+q\log n)$。</p></details><h3 id=ur-1缩进优化>【UR #1】缩进优化
<a class=header-anchor href=#ur-1%e7%bc%a9%e8%bf%9b%e4%bc%98%e5%8c%96></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>考虑枚举每个 $x$ 计算答案。</p><p>假设值域为 $v$，我们只用知道若干区间内的总和及带权和即可。</p><p>使用前缀和即可维护。</p><p>总复杂度 $O(n+v\log v)$。</p></details><h3 id=ur-1外星人>【UR #1】外星人
<a class=header-anchor href=#ur-1%e5%a4%96%e6%98%9f%e4%ba%ba></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>先排序，然后考虑有效的数一定单调减，我们在这些位置决策。</p><p>假设 $a_1\ge a_2\ge a_3\ge\dots\ge a_n$。</p><p>假设 $f_{i,v}$ 表示考虑到第 $i$ 项，模后值为 $v$ 的方案数。</p><p>特别的，$f_{0,v}=[v=x]$。</p><p>显然</p><p>$$f_{j,v\bmod a_j}\leftarrow\frac{(n-i-1)!}{(n-j)!}f_{i,v}\quad(i&lt;j)$$</p><p>于是直接前缀和优化 dp 就是 $O(nv)$ 的了。</p></details><h3 id=ur-2跳蚤公路>【UR #2】跳蚤公路
<a class=header-anchor href=#ur-2%e8%b7%b3%e8%9a%a4%e5%85%ac%e8%b7%af></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>upd：这个做法假了。</p><p>注意到发财等价于路径上存在负权环。</p><p>只用计算每个源点可能到达的点往自己在 $x$ 在什么范围时可能有负权环，最后把其所能到达的点更新一下即可。</p><p>我们可以把每个 SCC 拆开来考虑。对每个 SCC 设其中一个点 $s$ 作为源点即可，容易发现此时不存在负环等价于不存在经过 $s$ 的负环。</p><p>设 $f(p,j)$ 为从 $s$ 点到 $p$ 点经过 $j$ 个 $x$ 的情况下剩余部分的最小代价。</p><p>如果 $f(s,0)=-\infty$，显然始终存在负环。</p><p>否则如果 $f(s,0)=0$，假设 $f(s,a)$ 与 $f(s,b)$ 两项将导致 $\mathbb R$ 上 $x$ 解集为空（$a&lt;0&lt;b$），则有 $\min{f(s,a)+ax,f(s,b)+bx}&lt;0,\forall x\in\mathbb R$，也即 $\frac{f(s,b)}{b}&lt;\frac{f(s,a)}{a}$，从而 $bf(s,a)+(-a)f(s,b)&lt;0$，于是 $f(s,0)=-\infty$，矛盾。</p><p>因此 $\mathbb R$ 上必定存在一组合法的 $x$。容易发现，此时 $x$ 应当满足</p><p>$$-\frac{f(s,b)}{b}\le x\le-\frac{f(s,a)}{a}$$</p><p>考虑怎么快速计算出 $f(s,j)$。</p><p>考虑用 SPFA 松弛，如果计算过程中出现任一恒负环就无解。</p><p>否则 SPFA 可以在 $O(n^3m)$ 内出解：分层图边数 $O(nm)$，点数 $O(n^2)$。不过我写了如果进队 $8n$ 次就直接判无解，这样就是 $O(n^2m)$ 的了。</p><p>垂死病中惊坐起，这个复杂度假的！</p><p>我们大力猜测出题人没卡，然后大力写就是了。</p></details><h3 id=ur-2树上gcd>【UR #2】树上GCD
<a class=header-anchor href=#ur-2%e6%a0%91%e4%b8%8agcd></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>我们考虑分开 $u$ 是 $v$ 的祖先的贡献，和不是祖先的贡献。</p><p>对于 $u$ 是 $v$ 祖先的部分，我们可以在 $v$ 处统计合法的 $\operatorname{dist}(u,v)$，显然是 $1\sim\operatorname{dep}(v)$，差分即可得到每种方法的数目。（认为根节点深度为 $0$）</p><p>对于 $u$ 不是 $v$ 祖先的部分，我们考虑容斥。</p><p>考虑对每个 $g$ 计算有多少点对 $u,v$ 满足 $g|\operatorname{dist}(u,r),g|\operatorname{dist}(v,r)$，其中 $r=\operatorname{lca}(u,v)\neq u,u&lt;v$。</p><p>考虑对 $g>B$ 和 $g\le B$ 讨论。</p><p>对于 $g>B$ 的部分，我们考虑长剖，在 $r$ 处统计 $g$ 的贡献。</p><p>在合并一个短段时，暴力加上长段中其对应的贡献。</p><p>容易发现只在短段长度 $>B$ 时才会统计，因此最多统计 $n/B$ 次，枚举的 $g$ 的总数目不超过 $n$，于是总复杂度即为 $O(n^2/B)$。</p><p>对于 $g\le B$ 的部分，我们考虑对每个 $g$ 暴力枚举答案，则我们可以对元素按模 $g$ 余数的高度分类，进行 dp 即可。直接做单轮是可以做到 $O(n)$ 的，故该部分总复杂度 $O(nB)$。</p><p>容斥的部分复杂度可以忽略不计，取 $B=\sqrt n$，总复杂度 $O(n\sqrt n)$。</p><p>实测 $B$ 比较小的时候这个比较快。</p><p>考虑如何卡满这个复杂度。</p><p>考虑一条长度为 $n/2$ 的链，并且在根节点处挂 $n/4B$ 个长为 $2B$ 的链。那么容易发现每次合并的复杂度是 $O(n)$ 的。</p><p>这样就卡满了 $O(n^2/B)$。</p></details><h3 id=ur-3铀仓库>【UR #3】铀仓库
<a class=header-anchor href=#ur-3%e9%93%80%e4%bb%93%e5%ba%93></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>Fact 1：任意一种选法方案的最小时间是到起点距离和的 $2$ 倍。</p><p>Fact 2：任意一种最优解均可以从某个已有的位置开始，向左右挑一个近的扩展，来得到。</p><p>我们枚举起点，然后二分套二分，即为 $O(n\log n\log v)$。</p><p>考虑怎么优化。</p><p>注意到当起点单调增时，我们总可以令最优的最右端点不减，尺取即可解决。对左右暴力扩展即可。</p></details><h3 id=ur-3链式反应>【UR #3】链式反应
<a class=header-anchor href=#ur-3%e9%93%be%e5%bc%8f%e5%8f%8d%e5%ba%94></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>简单 GF。</p><p>假设答案的 EGF 为 $g$，光子选法的 EGF 为 $f$，则</p><p>$$g&rsquo;=1+g^2f/2$$</p><p>写一个在线卷积即可解决。</p><p>即，设 $h=g^2/2$，则有</p><p>$$g&rsquo;=1+hf,h=g^2/2$$</p><p>从而</p><p>$$g_n=[n=1]+\frac{1}{n}\sum_jh_jf_{n-j-1}$$</p><p>$$h_n=\frac12\sum_jg_jg_{n-j}$$</p><p>直接同时处理就好了。总复杂度 $O(n\log^2n)$。</p></details><h3 id=ur-4元旦激光炮>【UR #4】元旦激光炮
<a class=header-anchor href=#ur-4%e5%85%83%e6%97%a6%e6%bf%80%e5%85%89%e7%82%ae></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>肯定是卡二分次数，起码优化到 $O(\log n)$，关键是怎么卡。</p><p>考虑到我们其实每次查询 $3$ 个位置 $u,v,w$，如果有 $u+v+w=k$，则我们可以找到其中最大、最小的数，答案显然在这之间，从而压缩了这两者的上下界。</p><p>当对于一个数来说其选法上下界确定时，我们就转化成了只剩下 $2$ 项的子问题。</p><p>对于只有 $2$ 项的子问题，我们二分其中一个就做完了。</p><p>考虑原问题中怎么快速把至少一个缩到紧界。</p><p>假设现在上界 $r_1,r_2,r_3$，下界 $\ge1$，要求 $k$。</p><p>显然不妨 $r_1\le r_2\le r_3\le k\le r_1+r_2+r_3$。</p><p>考虑取三个数大致在 $r_1k/(r_1+r_2+r_3),r_2k/(r_1+r_2+r_3),r_3k/(r_1+r_2+r_3)$ 的附近。那么必然有一项下界抬升 $k/(r_1+r_2+r_3)$，一项上界降低 $1-k/(r_1+r_2+r_3)$，于是至少有一个区间长度减半。</p><p>这样在 $3\log$ 轮后就有一个数上下界固定了。</p><p>这样的总查询次数看上去是 $11\log$ 的。</p><p>注意到整个过程是一体的，因此总次数不会超过 $9\log$ 级别。</p><p>我们猜测实际次数跑不满，或者可以分析出更紧的界。</p><p>嗯做就是了。</p><p>乱写一通就过了。</p></details><h3 id=ur-5怎样提高智商>【UR #5】怎样提高智商
<a class=header-anchor href=#ur-5%e6%80%8e%e6%a0%b7%e6%8f%90%e9%ab%98%e6%99%ba%e5%95%86></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>手玩一下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-0-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-0-1>1</a></span><span>A 0 0 0 0
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-1-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-1-1>1</a></span><span>A 0 0 0 0
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-1-2><a style=outline:none;text-decoration:none;color:inherit href=#hl-1-2>2</a></span><span>A 0 0 0 0
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-2-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-2-1>1</a></span><span>A 0 0 0 0
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-2-2><a style=outline:none;text-decoration:none;color:inherit href=#hl-2-2>2</a></span><span>A 0 0 0 0
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-2-3><a style=outline:none;text-decoration:none;color:inherit href=#hl-2-3>3</a></span><span>A 0 0 0 0
</span></span></code></pre></div><p>似乎都是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-3-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-3-1>1</a></span><span>A 0 0 0 0
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-3-2><a style=outline:none;text-decoration:none;color:inherit href=#hl-3-2>2</a></span><span>A 0 0 0 0
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-3-3><a style=outline:none;text-decoration:none;color:inherit href=#hl-3-3>3</a></span><span>...
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-3-4><a style=outline:none;text-decoration:none;color:inherit href=#hl-3-4>4</a></span><span>A 0 0 0 0
</span></span></code></pre></div><p>？</p><p>此时答案即为 $4\times3^{n-1}$。</p><p>我们猜这是最优的。</p><p>然后就过了。</p></details><h3 id=ur-5怎样更有力气>【UR #5】怎样更有力气
<a class=header-anchor href=#ur-5%e6%80%8e%e6%a0%b7%e6%9b%b4%e6%9c%89%e5%8a%9b%e6%b0%94></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>显然就是求最小生成树，其中</p><p>$$w(u,v)=\min_{(u,v)\text{ 可于 Day }j\text{ 修建}}w_j$$</p><p>考虑 Kruskal，我们从小到大考虑，每次把当前链上所有不同的图上联通块能合并的都合并上。容易发现两个联通块不能直接连接当且仅当他们两两间均不可联通。</p><p>直接做是没法做的，我们不妨先考虑 $p=0$ 的情况，显然此时我们只用加树边，从大到小枚举方案，树剖维护链染色即可。</p><p>对于 $p>0$ 的情况，仍然考虑从大到小染色替换，把树边能染的都染了，不能染的树边会把链分成若干段，剩下的这些链之间看看互相能不能染，把链之间“不能相连”的边找出，然后 dfs 即可知道剩下这些链直接互相连的方法，把那些边单独提出即可。</p><p>最后提取树边和非树边信息再做一次 Kruskal 即可。</p><p>总复杂度 2log，容易通过。常数瓶颈在 ODT 维护染色上。（不过如果写 Splay 复杂度就是 1log 的了）</p><p>考虑怎么小常数地优化这一块。</p><p>注意到我们是染色之后最后查询全局，我们可以把染色的部分离线下来，dfs 一遍整颗树，然后拿一个可并可删堆维护一下染色即可。</p></details><h3 id=ur-5怎样跑得更快>【UR #5】怎样跑得更快
<a class=header-anchor href=#ur-5%e6%80%8e%e6%a0%b7%e8%b7%91%e5%be%97%e6%9b%b4%e5%bf%ab></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>看到 $\gcd/\operatorname{lcm}$ 的等式，考虑反演。</p><p>$$\sum_j\gcd{i,j}^c\operatorname{lcm}{i,j}^dx_j=b_i$$</p><p>$$\sum_j\gcd{i,j}^{c-d}(j^dx_j)=\frac{b_i}{i^d}$$</p><p>设 $y_j=j^dx_j$，$a_i=b_i/i^d$，$s=c-d$，则有</p><p>$$\sum_j\gcd{i,j}^sy_j=a_i$$</p><p>考虑设</p><p>$$\sum_{d|m}h_d=m^s$$</p><p>则</p><p>$$\sum_jy_j\sum_{d|i,d|j}h_d=a_i$$</p><p>从而</p><p>$$\sum_{d|i}h_d\sum_{d|j}y_j=a_i$$</p><p>设 $S_d=h_d\sum_{d|j}y_j$，我们有</p><p>$$\sum_{d|i}S_d=a_i$$</p><p>从而 $S_d$ 易解，于是就可以推出</p><p>$$\sum_{d|j}y_j=S_d/h_d$$</p><p>从而可以解出 $y$。</p><p>如果 $S_d\neq0\land h_d=0$，则无解。</p><p>朴素实现是 $O(n\log n)$ 的。使用狄利克雷前缀和即可做到单轮 $O(n\log\log n)$，不过没啥必要。</p></details><h3 id=新年的巧克力棒>新年的巧克力棒
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84%e5%b7%a7%e5%85%8b%e5%8a%9b%e6%a3%92></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>答案显然是 $n-\operatorname{popcount}(n)$。证明容易归纳。</p><p>然后就做完了。</p></details><h3 id=新年的毒瘤>新年的毒瘤
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84%e6%af%92%e7%98%a4></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>首先由于合法等价于删掉后是一棵树，因此也就等价于删掉后 $m=n-1$ 且图联通。</p><p>前一条可以使用当前节点的度数判，后一条则等价于当前点不是割点，直接做即可。</p><p>总复杂度 $O(n)$。</p><p>需要特判 $m=n-2$ 的情况。</p></details><h3 id=新年的桌游>新年的桌游
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84%e6%a1%8c%e6%b8%b8></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>称四种牌分别为 $\tt A$，$\tt B$，$\tt C$，$\tt D$。</p><p>双方的数目分别称为 $(a/b/c/d)_{0/1}$。</p><p>如果 $c_0>a_1\lor(a_0>0\land b_1=0)$，显然先手胜。</p><p>否则先手肯定把 $c_0$ 先用完，使 $a_1\leftarrow a_1-c_0$，$c_0\leftarrow0$，然后看看如果 $a_0\ge a_1\land d_0>0$，则先手胜。</p><p>否则看看对手是否能在下一轮直接弄死自己，如果能就输了。</p><p>否则，再使 $a_0\leftarrow a_0-c_1$，$c_1\leftarrow0$，这样接下来就不用考虑 $\tt C$ 的影响了。</p><p>接着看看先手能不能出 $\tt A$。</p><p>如果 $d_0=d_1=0$，显然双方会保持出 $\tt A$ 直到一方被创死或者无法移动。</p><p>如果 $d_0>0\land d_1=0$，先看看按刚刚的策略谁胜，再看看如果自己会输那么有没有 $a_1-b_0\le a_0$，如果有就平局。因为显然有 $b_1\ge a_0\lor b_0&lt;b_1$，所以不能借机反杀。</p><p>如果 $d_0=0\land d_1>0$，先看看先手第一步出 $\tt A$ 的结果，然后看不出的结果，显然先手会取其中较好的结果。</p><p>这里不会有 $d_1>0\land d_2>0$ 的情况，否则必然会在前两轮中结束。</p><p>这样就做完了。</p></details><h3 id=新年的qaq>新年的QAQ
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84qaq></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>比较简单的题目！</p><p>考虑计算一个东西的时候计算两次，再计算其差值，然后如果差值非 $0$ 则重算。</p><p>这个东西容易实现。</p><p>这样每种运算均可以做到比较高的正确率，直接做就好了。</p><p>输出大概长这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-1> 1</a></span><span>input n
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-2><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-2> 2</a></span><span>input m
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-3><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-3> 3</a></span><span>a = 1
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-4><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-4> 4</a></span><span>b = 0
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-5><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-5> 5</a></span><span>c = a + b
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-6><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-6> 6</a></span><span>d = a + b
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-7><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-7> 7</a></span><span>e = c - d
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-8><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-8> 8</a></span><span>if e goto 5
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-9><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-9> 9</a></span><span>f = c % m
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-10><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-10>10</a></span><span>g = c % m
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-11><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-11>11</a></span><span>h = f - g
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-12><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-12>12</a></span><span>if h goto 9
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-13><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-13>13</a></span><span>i = n - 1
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-14><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-14>14</a></span><span>j = n - 1
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-15><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-15>15</a></span><span>k = i - j
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-16><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-16>16</a></span><span>if k goto 13
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-17><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-17>17</a></span><span>a = b
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-18><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-18>18</a></span><span>b = f
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-19><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-19>19</a></span><span>n = i
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-20><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-20>20</a></span><span>if n goto 5
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-4-21><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-21>21</a></span><span>output b
</span></span></code></pre></div></details><h3 id=ur-6破解密码>【UR #6】破解密码
<a class=header-anchor href=#ur-6%e7%a0%b4%e8%a7%a3%e5%af%86%e7%a0%81></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>容易发现</p><p>$$26h_j-h_{j+1}\equiv(26^n-1)w_j\pmod p$$</p><p>如果</p><p>$$26^n\not\equiv1\pmod p$$</p><p>则</p><p>$$w_j=\frac{26h_j-h_{j+1}}{26^n-1}\pmod p$$</p><p>否则，我们有</p><p>$$26h_j\equiv h_{j+1}\pmod p$$</p><p>因此随意构造使 $h_0$ 处合法即可。直接取模升位即可找到一组解。</p></details><h3 id=ur-6智商锁>【UR #6】智商锁
<a class=header-anchor href=#ur-6%e6%99%ba%e5%95%86%e9%94%81></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>hhz 其实以前和我们讲过这题。。。</p><p>考虑到这种题目一眼就不可做，于是就考虑通过一些人类智慧的乱搞解决。</p><p>首先一张图的生成树个数可以用矩阵树定理算出。</p><p>考虑先生成大量点数比较少的图，计算出其生成树个数。</p><p>然后用一条链把这些图串起来，这样方案数就是各部分的乘积。</p><p>根据当初 hhz 给的介绍，我们暴力随出 $100000$ 张点数不超过 $12$ 的联通图，然后每组询问把若干图直接拼在一起即可。。。</p><p>问题是怎么拼，其实每次随一个拼上直到找到为止，找不到就重随一个就行了233。</p><p>特判掉 $k=0$ 就好了。</p></details><h3 id=ab-problem>A+B Problem
<a class=header-anchor href=#ab-problem></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>考虑大力跑流。</p><p>我们考虑构造一个最小割模型，共 $3n+2$ 个点，$S$ 与左部点连边 $b$，右部点与 $T$ 连边 $w$，左右部点直接对应用 $+\infty$ 相连，左部点往中部点连边权 $p$，中部点和可能影响之的右部点用 $+\infty$ 相连。</p><p>这样答案即为 $\sum b+\sum w-c$，其中 $c$ 为最小割大小。</p><p>直接做边数是 $O(n^2)$ 的，按 uoj 的数据强度肯定是过不去的。</p><p>所以直接上主席树优化建图，即可做到 $O(n\log n)$ 个点，$O(n\log n)$ 条边，应该就能松过去了。</p><p>最好先进行值域离散化。</p><p>然后上面这种做法可能会导致某项两侧均被割掉从而答案错误，所以考虑怎么办。</p><p>考虑初始给 $b,w$ 均加上一个极大数 $A=300000$，使得一但割掉 $n+1$ 个颜色就会带来过大的代价，不如直接选择，从而保证正确性。</p></details><h3 id=ur-7水题生成器>【UR #7】水题生成器
<a class=header-anchor href=#ur-7%e6%b0%b4%e9%a2%98%e7%94%9f%e6%88%90%e5%99%a8></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>我们考虑假设已经解决了 $(n-1,\lfloor\frac{m}{n}\rfloor)$ 的问题，要解决 $(n,m)$ 的问题。</p><p>首先我们把 $\lfloor\frac{m}{n}\rfloor$ 的答案全部乘 $n$，变成 $n\lfloor\frac{m}{n}\rfloor$ 的答案。</p><p>然后如果 $m\neq n\lfloor\frac{m}{n}\rfloor$，我们再加入一项 $m-n\lfloor\frac{m}{n}\rfloor$。</p><p>这样就用 $n-1$ 解决了 $n$。</p><p>而对于 $n=1$ 的部分，容易直接计算。</p><p>这个做法容易写成循环的形式，进而做到 $O(n)$。</p></details><h3 id=ur-7水题走四方>【UR #7】水题走四方
<a class=header-anchor href=#ur-7%e6%b0%b4%e9%a2%98%e8%b5%b0%e5%9b%9b%e6%96%b9></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>注意到两个人中比较高的那个不可能更高了，因此我们对其设状态。</p><p>设 $f_p$ 为子树中叶子节点的个数。</p><p>设 $g_p$ 为子树中一人在根节点不动，一人从根开始在子树内游走的最小答案。</p><p>设 $h_p$ 为子树中两人从根开始的最小答案。</p><p>答案即为 $h_1$。</p><p>我们设 $d_{p,0/1}$ 为子树中最深、次深节点距自己的距离，且要求来自不同子树。这个容易 dp 维护。</p><p>从而</p><div>$$f_p=\begin{cases}1&p\text{ is a leaf.}\\\sum_sf_s&\text{otherwise.}\end{cases}$$</div><div>$$g_p=\begin{cases}0&p\text{ is a leaf.}\\\sum_s(f_s+g_s)&\text{otherwise.}\end{cases}$$</div><div>$$h_p=\begin{cases}0&p\text{ is a leaf.}\\h_s+1&p\text{ has just }1\text{ son.}\\g_p-\max_q\{g_q+f_q\operatorname{dist}(p,q))+h_q+[\operatorname{dist}(p,q)>d_{p,1}] (\operatorname{dist}(p,q)-d_{p,1}\}&\text{otherwise.}\end{cases}$$</div><p>这样就可以 $O(n^2)$ 转移了。</p><p>考虑优化，我们不妨规定<strong>当前转移总满足 $\operatorname{dist}(p,q)\le d_{p,1}$</strong>，于是就有代价形如</p><p>$$g_p-(g_q+f_q\operatorname{dist}(p,q))+h_q$$</p><p>的形式。容易发现这样子可以取到所有最优方案。</p><p>对于快速找到所有合法节点并更新的复杂度，使用长剖最多跳根号条重链的结论即可以分析出为 $O(n\sqrt n)$。</p><p>我们的目标是找到最大的 $g_q+f_q\operatorname{dist}(p,q)-h_q$ 使得 $\operatorname{dist}(p,q)\le d_{p,1}$。</p><p>容易发现，这种贡献转移可以写作</p><p>$$(g_p-h_p)\leftarrow(g_q-h_q)+f_q\operatorname{dist}(p,q)$$</p><p>注意到我们只用维护 $g_p-h_p$ 的转移，如果用 $w=g-h$ 改写，则应当形如</p><div>$$w_p=\begin{cases}0&p\text{ is a leaf.}\\w_s+f_s-1&p\text{ has just }1\text{ son.}\\\max_{\operatorname{dist}(p,q)\le d_{p,1}}\{w_q+f_q\operatorname{dist}(p,q)\}&\text{otherwise.}\end{cases}$$</div><p>问题仅在于优化这个 $w_p$ 的计算。</p><p>注意到只用求出 $w_1$，于是可以改写成自顶向下的 dp。</p><p>设 $r_p$ 为从 $p$ 开始，通过 $w$ 的转移，来传递到根的最大贡献，则在 dp 时可以这么考虑：</p><div>$$r_p=\begin{cases}0&p\text{ is root.}\\\max\{\max_{p\in T(q),\deg q>1,\operatorname{dep}_p\le d_{q,1}+\operatorname{dep}_q}\{r_q+f_p\operatorname{dist}(q,p)\},r_a+f_p-1\}&a\text{ has just }1\text{ son }p\text{.}\\\max_{p\in T(q),\deg q>1,\operatorname{dep}_p\le d_{q,1}+\operatorname{dep}_q}\{r_q+f_p\operatorname{dist}(q,p)\}&\text{otherwise.}\end{cases}$$</div><p>我们注意到 $\operatorname{dist}(q,p)$ 可以被认为是 $q\sim p$ 的路径上除了 $q$ 以外的点的数目，因此可被认为是<strong>将一段路径上所有点的权值均用 $f_p$ 表示</strong>。</p><p>由于 $f$ 具有子树包含单调性，所以最优的 $q$ 一定选择为<strong>离自己最近的 $\deg>1$ 且合法的节点</strong>。容易发现这样子的方案一定不劣。（如果自己非要选更高的 $q$，我们发现这个较低的 $q$ 也一定可以选择用其更新，从而更优）</p><p>当递归到一个 $\deg>1$ 的节点时，我们可以开一个单调栈来进行压栈。</p><p>弹栈时我们可以暴力二分出应当在何处弹单调栈，查询时亦可二分。由于普通二分常数太大，所以其实更建议倍增。</p><p>使用可回退化数据结构即可做到 $O(n\log n)$，常数超级小，容易通过。</p></details><h3 id=mx的组合数>mx的组合数
<a class=header-anchor href=#mx%e7%9a%84%e7%bb%84%e5%90%88%e6%95%b0></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>myy 好厉害！不过这种技巧放到现在可能就已经家喻户晓了（x</p><p>一道类似的题目：bzoj 2629 binomial。</p><p>基本原理是，注意到我们有 Lucas 定理，我们可以把组合数拆进制，转化成数位 dp 问题。</p><p>问题转化为进行 $O(\log_pv)$ 轮两个长为 $p$ 的数组的下标乘法卷积和逐点加法。</p><p>逐点加法容易做到 $O(p)$，关键问题在于乘法卷积。</p><p>注意到 $p$ 是质数，因此我们直接找出原根，然后把除了 $0$ 位置之外的数全部用离散对数投影到 $[0,p-1)$ 上，转化成普通卷积，NTT 即可维护。</p><p>忽略掉找原根部分的复杂度，总复杂度 $O(p\log v)$，足以通过此题。</p></details><h3 id=mx的仙人掌>mx的仙人掌
<a class=header-anchor href=#mx%e7%9a%84%e4%bb%99%e4%ba%ba%e6%8e%8c></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>显然不弱于 bzoj2125 最短路。</p><p>先建出圆方树，圆方边按 bzoj2125 的方法建出来，这样两个圆点的最短路可以按 LCA 直接分类计算。</p><p>然后单组询问的时候，由于总点数被限制了，不难想到建立虚树。</p><p>建出虚树后在虚树上直接换根 dp 即可找出从每个子树到当前点的最长路，总复杂度 $O(n\log n)$，可以通过。</p><p>注意方点换根时需要一个单调队列。</p></details><h3 id=uer-2手机的生产>【UER #2】手机的生产
<a class=header-anchor href=#uer-2%e6%89%8b%e6%9c%ba%e7%9a%84%e7%94%9f%e4%ba%a7></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>这个我熟！</p><p>容易发现就是统计所有合法计算式数目，使得其满足短路原理。（每个位置分三种状态：未计算 / $0$ / $1$）</p><p>对于由 $n-1$ 个 <code>&&</code> 组成的计算式，其要么全是 $1$，返回 $1$；要么前一部分是 $1$，中间一个 $0$，后面未计算，返回 $0$。</p><p>对于由若干个 <code>&&</code> 计算式和 <code>||</code> 组成的计算式，要么每个子式都返回 $0$，要么前若干个返回 $0$，中间一个返回 $1$，后面的不计算。</p><p>这样，假设共有 $m$ 个子式，每个子式有 $a_j$ 个运算数，则答案即为</p><p>$$\sum_{j=0}^m\prod_{k=0}^{j-1}a_k$$</p><p>容易做到 $O(m)$。</p></details><h3 id=uer-2信息的交换>【UER #2】信息的交换
<a class=header-anchor href=#uer-2%e4%bf%a1%e6%81%af%e7%9a%84%e4%ba%a4%e6%8d%a2></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>这个题目很有趣！</p><p>注意到这个其实就是 tarjan 的生成森林，并且把每颗树的出栈序都循环位移了一下。于是我们提取出每个置换环单独处理，这样就得到了每个联通块的出栈序。</p><p>这样，每个节点的父亲可以是下一项，也可以是下一项的祖先（如果兄弟大于自己）。返祖边在祖先的该方向儿子节点小于自己时可以加。容易发现拿也是一个祖先，因此只有到根为止（不包括根）小于自己的节点其父亲可以和自己连返祖边。</p><p>注意到一个子树必然是一个区间，直接区间 dp 即可。</p><p>设 $f_{l,r}$ 为 $[l,r)$ 区间内的节点构成子树，且计算了返祖边贡献的方案数；设 $g_{l,r}$ 为 $[l,r)$ 区间内的节点构成子树，且计算了返祖边贡献，且可以再往前加一个子树的方案数。容易列出区间 dp 的转移。</p><p>总复杂度 $O(n^3)$，常数很小。</p></details><h3 id=uer-2谣言的传播>【UER #2】谣言的传播
<a class=header-anchor href=#uer-2%e8%b0%a3%e8%a8%80%e7%9a%84%e4%bc%a0%e6%92%ad></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>容易发现就是基环内向树上的路径。考虑构造方案让答案最小、最大。</p><p>最小解，我们先把树点全取父亲（如果能取），然后把环点全取父亲（如果能取），然后剩下点随便交替取（只要不取自己）。容易发现这样是最小的。</p><p>最大解就是深度和，考虑构造使得一个子树其差一个节点没取外面的点，且根节点没被取，容易加入一个子树时更新信息。在环上交错取即可。这样就取满了。</p><p>总复杂度 $O(n)$。</p></details><h3 id=ur-8赴京赶考>【UR #8】赴京赶考
<a class=header-anchor href=#ur-8%e8%b5%b4%e4%ba%ac%e8%b5%b6%e8%80%83></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>注意到行列对于移动时是否相同的贡献是独立的，分别求出最小值。</p><p>在环上两个方向分别对应一种走法，取 $\min$ 即可。</p><p>预处理前缀和，复杂度 $O(n+m+q)$。</p></details><h3 id=ur-8决战圆锥曲线>【UR #8】决战圆锥曲线
<a class=header-anchor href=#ur-8%e5%86%b3%e6%88%98%e5%9c%86%e9%94%a5%e6%9b%b2%e7%ba%bf></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>完全没思路，看了题解。</p><p>大概就是，只用注意到，如果有一个 $y_i\le y_j\land i&lt;j$ 的存在，那前面的 $i$ 对答案一定没有贡献。</p><p>然后使用类似于笛卡尔树的分析，期望只会有 $\log$ 个合法元素，具体就是从左往右依次加入的单调栈。</p><p>既然是单调栈，考虑直接上记录区间内最大元素，每次询问时直接往某个会出现答案的子树递归。</p><p>由于有 $2$ 操作，还应记录最小元素。</p><p>单次期望复杂度修改 $O(\log n)$，查询 $O(\log^2n)$。</p></details><h3 id=ur-9电路手动分析>【UR #9】电路手动分析
<a class=header-anchor href=#ur-9%e7%94%b5%e8%b7%af%e6%89%8b%e5%8a%a8%e5%88%86%e6%9e%90></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>考虑 $1\le a\le nm$ 个节点间已有的连边数目最多能有多少。</p><p>容易发现一个上界：$2a$。因为横的不多于 $a$，竖的不多于 $a$。</p><p>所以还要连的边数是 $a^2/2+O(a)$ 级别的。</p><p>因此我们的答案大概是 $\sqrt{2r}+O(1)$ 级别的。</p><p>考虑二分答案 check 一个 $a$ 对应的最多连边数目，故有 $a=O(\sqrt r)$。考虑怎么 check。</p><p>简单来说，我们注意到最优解一定可以形如一个矩形接上顶部若干个点，我们设宽上有 $x$ 个点，则另一个方向上共有 $\lceil\frac ax\rceil$ 个点，总边数为 $2a-x-\lceil\frac ax\rceil$ 的。对行列边拆开分析容易发现这样最优。</p><p>注意到 $x$ 取到 $\sqrt a$ 附近时最优，直接暴力枚举一下即可；需要注意的是，我们总应有 $x\le n\land\lceil\frac ax\rceil\le m$ 或者 $x\le m\land\lceil\frac ax\rceil\le n$，把边界情况也扫一下就好了。</p><p>如果不想动脑，也可以直接数论分块枚举。</p></details><h3 id=ur-9app-管理器>【UR #9】App 管理器
<a class=header-anchor href=#ur-9app-%e7%ae%a1%e7%90%86%e5%99%a8></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>做法假了，贺题解。</p><p>注意到就是定向使得最终为强连通分量。</p><p>大概做法是，把还未定向的边视作双向边，则除了当前考虑的边外，剩下的边一定存在方案使得两个被当前边连接的点中一个可以到达另一个。</p><p>直接把还不能到达的方向的边连上即可；否则随便连一条边即可。</p></details><h3 id=uer-3开学前的作文>【UER #3】开学前的作文
<a class=header-anchor href=#uer-3%e5%bc%80%e5%ad%a6%e5%89%8d%e7%9a%84%e4%bd%9c%e6%96%87></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>考虑分类讨论。不妨 $n\le m$。</p><p>我们认为起点是 $(0,0)$，终点是 $(n,m)$。</p><p>如果 $n=0$，如果 $m\le1$，答案为 $m$，否则答案为 $\lceil m/2\rceil+1$。</p><p>否则，如果 $n=m$，显然即为 $n+1$。</p><p>否则，答案即为 $n+2+\lfloor(m-n)/2\rfloor$。</p><p>然后就完了。</p></details><h3 id=uer-3开学前的日历>【UER #3】开学前的日历
<a class=header-anchor href=#uer-3%e5%bc%80%e5%ad%a6%e5%89%8d%e7%9a%84%e6%97%a5%e5%8e%86></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>题目里的 $(u+i,v-i+j)$ 比较混乱邪恶，我们考虑把各行依次平移，使得修改的位置变为 $(u+i,u+v+j)$。</p><p>先考虑 $k=0$ 怎么做。</p><p>注意到</p><p>$$\binom{j}{i}=\binom{j-1}{i-1}+\binom{j-1}{i}$$</p><p>这样只用在 $(u,u+v)$ 处加 $1$，每位分别向其右方和右下方作贡献即可。</p><p>当 $k\ge0$ 时，由于只有 $j\ge k$ 可以被贡献，我们考虑在 $(u,u+v+k)(u+1,u+v+k)(u+2,u+v+k)\dots(u+k,u+v+k)$ 处依次加上对应组合数的贡献即可。</p><p>考虑怎么实现这种效果。</p><p>考虑对每个 $k$ 分别处理，在 $(u,u+v+k)$ 处加 $1$，并考虑最后在计算出各部分系数 $a_{k,u,v}$。</p><p>那么最终一个位置 $(u,v)$ 被贡献的系数将是 $\sum_k\sum_{j=0}^k\binom kja_{k,u,v-j}$。</p><p>该部分直接暴力计算是 $O(n^4)$ 的（认为 $n,m$ 同阶），不优。</p><p>注意到，由于 $\binom{k}{j}=\binom{k-1}{j-1}+\binom{k-1}{j}$，我们可以把 $a_{k,u,v}$ 的贡献再移到 $a_{k-1,u,v}$ 和 $a_{k-1,u,v+1}$ 处，这样最后的 $a_{0,u,v}$ 即是答案。</p><p>总复杂度 $O(n^3+q)$。</p></details><h3 id=uer-3开学前的涂鸦>【UER #3】开学前的涂鸦
<a class=header-anchor href=#uer-3%e5%bc%80%e5%ad%a6%e5%89%8d%e7%9a%84%e6%b6%82%e9%b8%a6></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>注意到 $m-n\le k-1$，考虑使用广义串并联图方法。</p><p>我们可以反复删割边（或者删一度点），缩二度点，叠合重边；每条边边权定义为左右分裂的方案数和将左右联通的方案数 $(u,v)$。</p><p>当删掉割边时，对答案带来将左右直接联通的贡献，并裂开左右两侧，转成子问题；如果是删一度点，则只用考虑一侧子问题。</p><p>当缩二度点时，$(u&rsquo;,v&rsquo;)\leftarrow(u_1v_2+u_2v_1,v_1v_2)$。</p><p>当叠合重边时，$(u&rsquo;,v&rsquo;)\leftarrow(u_1u_2,u_1v_2+u_2v_1+v_1v_2)$。</p><p>反复操作直到图上没有割边（或者一度点）且无法缩二度点、叠合重边。</p><p>此时图上节点数会很少，显然不会多于 $2k-2$，直接状压 dp 即可。</p><p>即，设 $f_S$ 为 $S$ 联通的方案数，$g_S$ 为 $S$ 的总选法数，容易有 $g_S=\sum_{T\subseteq S,a\in T}f_Tg_{S-T}\prod_{x\in T,y\in S-T}v_{x,y}$，而 $a$ 为 $T$ 中的某个元素。</p><p>然后嗯上半半在线卷积就做完了。</p><p>简单来说，就是令 $(u,v)\leftarrow(u/v,1)$，且答案乘 $v$；对于 $v=0$ 的边，我们把两侧暴力缩点即可。</p><p>这样就变成了</p><p>$$g_S=\sum_{T\subseteq S,T\neq\varnothing,a\in T}f_Tg_{S-T}$$</p><p>$$f_S=g_S-\sum_{T\subsetneq S,T\neq\varnothing,a\in T}f_Tg_{S-T}$$</p><p>钦定 $a=0$，使用半半在线卷积即可维护。</p><p>草草草我 $3^{2k}$ 怎么过了？？？？？？？</p><p>加了组 hack。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-1> 1</a></span><span>18 10
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-2><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-2> 2</a></span><span>1 2
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-3><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-3> 3</a></span><span>2 3
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-4><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-4> 4</a></span><span>3 4
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-5><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-5> 5</a></span><span>4 5
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-6><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-6> 6</a></span><span>5 6
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-7><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-7> 7</a></span><span>6 7
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-8><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-8> 8</a></span><span>7 8
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-9><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-9> 9</a></span><span>8 9
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-10><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-10>10</a></span><span>9 10
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-11><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-11>11</a></span><span>10 11
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-12><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-12>12</a></span><span>11 12
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-13><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-13>13</a></span><span>12 13
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-14><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-14>14</a></span><span>13 14
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-15><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-15>15</a></span><span>14 15
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-16><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-16>16</a></span><span>15 16
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-17><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-17>17</a></span><span>16 17
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-18><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-18>18</a></span><span>17 18
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-19><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-19>19</a></span><span>18 1
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-20><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-20>20</a></span><span>1 10
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-21><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-21>21</a></span><span>2 11
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-22><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-22>22</a></span><span>3 12
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-23><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-23>23</a></span><span>4 13
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-24><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-24>24</a></span><span>5 14
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-25><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-25>25</a></span><span>6 15
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-26><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-26>26</a></span><span>7 16
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-27><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-27>27</a></span><span>8 17
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-5-28><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-28>28</a></span><span>9 18
</span></span></code></pre></div><p>然后我的代码还是常数太小冲过去了？？？甚至跑得比半半在线卷积还快？？？</p><p>把两部分代码拼在了一起。</p></details><h3 id=uer-4被粉碎的数字>【UER #4】被粉碎的数字
<a class=header-anchor href=#uer-4%e8%a2%ab%e7%b2%89%e7%a2%8e%e7%9a%84%e6%95%b0%e5%ad%97></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>一眼数位 dp。</p><p>我们考虑在状态中记录，目前从低往高考虑到了第几位；已考虑部分的 $f(x)-f(kx)$；$kx$ 进位后还没有计算的值；目前已考虑部分是否合法。</p><p>总状态数大约是 $\log_Bv\times2B\log_Bv\times k\times2$ 的。（$B=10$，认为 $k\ll v$）</p><p>直接 dp 即可。</p><p>转移复杂度还要乘上 $B$。</p><p>总复杂度 $O(kB^2\log_B^2v)$。</p></details><h3 id=uer-5万圣节的南瓜灯>【UER #5】万圣节的南瓜灯
<a class=header-anchor href=#uer-5%e4%b8%87%e5%9c%a3%e8%8a%82%e7%9a%84%e5%8d%97%e7%93%9c%e7%81%af></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>合法等价于树。</p><p>点减边容斥一下，我们转化为判断剩余的图是否联通。</p><p>注意到如果点减边等于 $1$，那么由于初始点数 $nm$，边数 $(2n-1)m$，我们得到最后剩下的边数为 $nm-k-1$，因此用掉了 $(n-1)m+k+1$ 条边，于是 $4k\ge(n-1)m+k+1$，从而点数是 $O(k)$ 级别的。</p><p>故直接把所有点掏出来连边判断即可。</p></details><h3 id=uer-5万圣节的数列>【UER #5】万圣节的数列
<a class=header-anchor href=#uer-5%e4%b8%87%e5%9c%a3%e8%8a%82%e7%9a%84%e6%95%b0%e5%88%97></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>经典题。</p><p>考虑把奇偶分开，前一半奇数，后一半偶数，转化成除二的子问题（值域除二）。</p><p>显然两者之间不会存在一个 $\ge3$ 的等差子序列。</p><p>当序列中所有值相等时，直接任意排列即可。</p><p>总复杂度 $O(n\log v)$。</p></details><h3 id=uer-5万圣节的糖果>【UER #5】万圣节的糖果
<a class=header-anchor href=#uer-5%e4%b8%87%e5%9c%a3%e8%8a%82%e7%9a%84%e7%b3%96%e6%9e%9c></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>感觉很有趣啊！</p><p>以下设有 $m$ 个数，$n$ 堆。</p><p>考虑从小到大依次加入数。</p><p>假设初始时各堆均可以为空。假设前 $a$ 个堆开头为奇数，后 $n-a$ 个堆开头为偶数。</p><p>考虑加入一对数 $2k-1,2k$，则开头为奇数的序列数不会发生变化。</p><p>但是并不是各堆均可以为空的，因此考虑容斥。</p><p>设前 $a$ 个堆开头为奇数，后 $b$ 个堆开头为偶数，可以为空的方案数为 $f_{a,b}$。</p><p>设前 $a$ 个堆开头为奇数，后 $b$ 个堆开头为偶数，不可以为空的方案数为 $g_{a,b}$。</p><p>则</p><p>$$f_{a,b}=\sum_{i\le a}\sum_{j\le b}\binom ai\binom bjg_{i,j}$$</p><p>我们要求的答案即为</p><p>$$\sum_j\binom njg_{j,n-j}$$</p><p>设 $F_n=\sum_j\binom njf_{j,n-j}$，$G_n=\sum_j\binom njg_{j,n-j}$，则我们有</p><div>$$F_n=\sum_j\binom njf_{j,n-j}\\=\sum_j\binom nj\sum_a\sum_b\binom ja\binom{n-j}bg_{a,b}\\=\sum_a\sum_b\binom{a+b}{a}g_{a,b}\binom{n}{a+b}2^{n-a-b}\\=\sum_j2^{n-j}\binom njG_j$$</div><p>二项式反演一下，得到</p><p>$$G_n=\sum_j(-2)^{n-j}\binom{n}{j}F_j$$</p><p>只用求出 $F_0\sim F_n$ 即可。这个是平凡的，因为我们有</p><p>$$f_{a,b}=a^{\lceil\frac m2\rceil}(b+1)^{\lfloor\frac m2\rfloor}$$</p><p>总复杂度 $O(n^2+n\log m)$，使用卷积容易优化到 $O(n\log m)$。</p></details><h3 id=ur-10汉诺塔>【UR #10】汉诺塔
<a class=header-anchor href=#ur-10%e6%b1%89%e8%af%ba%e5%a1%94></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>这个，我们考虑解决一根柱子上 $n$ 个点的排序。</p><p>如果 $n=1$，直接返回即可。</p><p>否则，分上一半下一半，把上一半排序后倒置，下一半同理，然后归并到一根柱子上即可。</p><p>总操作次数为 $O(n\log n)$ 的。</p></details><h3 id=ur-10世界线>【UR #10】世界线
<a class=header-anchor href=#ur-10%e4%b8%96%e7%95%8c%e7%ba%bf></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>忽视掉询问次数的限制，我们期望得到一个怎样的构造？</p><p>$n=1$ 不用构造。</p><p>$n=2$ 无法构造。</p><p>$2\nmid n$ 可以通过成对匹配来构造。即，第一次连接 $(1,2)(3,4)\dots(n-2,n-1)$，第二次连接 $(2,3)(4,5)\dots(n-1,n)$。</p><p>$2|n$ 可以忽略第 $n$ 项，转化成 $n-1$ 的问题。</p><p>这样的询问次数是 $O(n^2)$ 的。</p><p>随机化一下，每轮次数就是大约 $n^2/8$ 的。</p><p>明显过不去。</p><p>能不能稍微优化一下？</p><p>考虑一个杨表状结构，满足第 $i$ 行恰有 $T+1-i$ 个格子，共有 $\frac{T(T+1)}{2}$ 个格子。</p><p>第一轮把每行连起来，第二轮把每列连起来。</p><p>这样每轮的联通块个数会是 $O(T)$ 级别的。</p><p>剩下的 $n-\frac{T(T+1)}{2}$ 个节点个数显然是 $O(T)$ 的，直接按前面的暴力做法去做即可。注意剩下部分大小不可恰好为 $2$，且 $T$ 必须足够大以免寄掉。</p><p>查询时，我们每次只用不超过 $2T$ 次查询，即可知其当前所属联通块。</p><p>最后按照两组询问分别对应的联通块大小，容易回推出其原本所属的位置；暴力部分直接跳链即可。</p><p>查询次数显然不超过 $4nT$，其中 $T=\sqrt{2n}$。</p><p>考虑到如果随机排列原串，则每次查询时所遇到的节点个数不会很多，我们猜测这就能过了。</p></details><h3 id=ur-11元旦老人与丛林>【UR #11】元旦老人与丛林
<a class=header-anchor href=#ur-11%e5%85%83%e6%97%a6%e8%80%81%e4%ba%ba%e4%b8%8e%e4%b8%9b%e6%9e%97></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>我会猜结论！</p><p>一张图 $(V,E)$ 合法当且仅当对其任一张非空子图 $(V&rsquo;,E&rsquo;)$ 均有 $|E&rsquo;|\le2|V&rsquo;|-2$。</p><p>后者的必要性是显然的，充分性不会证 OvO。</p><p>考虑怎么判断这种东西。</p><p>如果规定一张子图 $(E&rsquo;,V&rsquo;)$ 的权值为 $|E&rsquo;|+2-2|V&rsquo;|$，则合法等价于其任一非空子图权值均非正。</p><p>考虑构造一个最大权闭合子图模型，如果选了一条边就必须选其对应的点，每条边权值为 $1$，每个点权值为 $-2$。显然可以最小割。</p><p>但这样是在一张子图权值是 $|E&rsquo;|-2|V&rsquo;|$ 情况下的解，无法判断存在一张子图满足 $|E&rsquo;|=2|V&rsquo;|-1$ 及 $|E&rsquo;|=2|V&rsquo;|$ 的情况。</p><p>因此我们考虑从图中删去某个点，那么合法等价于对任意一种删点方案均使源点满流。</p><p>怎么实现？</p><p>我们先不删点跑一次流，如果未满流肯定不合法。</p><p>否则，我们考虑通过找交错路流回汇点来将其满流。使用匈牙利算法之类的东西来实现这个是容易的，并且单轮复杂度只用 $O(n)$。</p><p>初始跑流的复杂度容易发现是和二分图最大匹配相同的，于是直接上匈牙利就做完了。</p><p>总复杂度 $O(n^2)$。常数超级小。</p><p>由于这张图看上去比较像正则，不知道可不可以套用那个
<a href=https://www.luogu.com.cn/blog/rqy/hall-theorem-regular-bigraph title=复杂度分析>复杂度分析
</a>，实际上随机数据下期望复杂度可能是 $O(n\log n)$ 的？（忽略掉清空数组的部分）</p></details><h3 id=ur-11元旦老人与数列>【UR #11】元旦老人与数列
<a class=header-anchor href=#ur-11%e5%85%83%e6%97%a6%e8%80%81%e4%ba%ba%e4%b8%8e%e6%95%b0%e5%88%97></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>吉司机线段树板子。</p><p>维护区间最小值，次小值，历史最小值，区间加的 tag，区间加的 tag 的历史最小值，最小值在上一次下传标记之后的历史最小值（也就是下传后又要还原了），最小值是否从左 / 右子树转移而来。</p><p>下传标记的部分属实比较奇妙，还是自己写一遍清楚。</p><p>这个东西只能分析到 $O(q\log^2n)$ 的复杂度，但是目前还不能卡满。所以直接写就是了。</p></details><h3 id=新年的破栈>新年的破栈
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84%e7%a0%b4%e6%a0%88></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>考虑贪心。</p><p>如果当前还未加入栈的元素中最小元素小于目前栈顶栈底，则保持入栈。</p><p>否则弹出栈顶或栈底。</p><p>容易发现这样最优。</p></details><h3 id=新年的网警>新年的网警
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84%e7%bd%91%e8%ad%a6></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>$p$ 合法等价于存在另一个节点 $q$ 使得 $\exists C,\forall c\neq p\land c\neq q,\operatorname{dist}(c,p)-\operatorname{dist}(c,q)=C$。</p><p>容易证明总不妨令 $C$ 满足 $\in{-1,0,1}$。</p><p>对于 $C=1$ 的情况，$\deg(p)=1$。</p><p>对于 $C=-1$ 的情况，$\deg(p\text{ 的一个邻居})=1$。</p><p>对于 $C=0$ 的情况，忽略掉边 $(p,q)$（如果存在）后，$p,q$ 所连的点集完全相同。</p><p>我们分 $(p,q)$ 是否存在讨论。</p><p>对于 $(p,q)$ 不存在的情况，就是所连点集相同。</p><p>否则，就是所连点集与自身构成的点集相同。</p><p>直接随机点权进行哈希即可快速判断。</p><p>复杂度 $O(n+m)$。</p></details><h3 id=新年的繁荣>新年的繁荣
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84%e7%b9%81%e8%8d%a3></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>首先，我们总不妨把权值相同的缩在一起。容易发现不劣。</p><p>然后考虑 Boruvka，我们考虑对每个联通块快速找到其对应连接其他联通块的最大边。</p><p>考虑构造一个数据结构 $A$，支持：</p><ul><li>插入一个数 $v$。</li><li>查询当前数集中和 $v$ 按位与最大的数。</li></ul><p>我们假设其单次操作复杂度为 $T$，预处理复杂度 $W$。</p><p>我们将目前各个联通块依次称为 $S_1,S_2,\dots,S_t$，那么我们找到每个联通块和之前、之后的联通块的最大边。这个可以正反两遍操作 $A$ 实现。</p><p>这样单轮的复杂度即为 $O(nT+W)$，进行 $O(\log n)$ 轮的总复杂度即为 $O((nT+W)\log n)$</p><p>使用 meet in the middle 容易做到 $T=O(2^{m/2}),W=O(2^m)$。</p><p>这个松一松就能过了。</p></details><h3 id=新年的腮雷>新年的腮雷
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84%e8%85%ae%e9%9b%b7></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>考虑二分答案。</p><p>我们从一个上界 $v$ 开始，那么我们可以由其反推出 $v-b_1,v-b_2,\dots,v-b_m$ 等上界。（如果当前数是通过拆得到的）</p><p>然后我们每次把最大数能拆则拆，不能拆则摆即可。</p><p>总复杂度 $O(n\log n\log(nv))$。</p><p>然后就光荣 WA 48pts 了。</p><p>因为你不知道最大数究竟能不能拆。这就比较寄。</p><p>。。。</p><p>实际上只要从 $v-\min b+1\sim v$ 之间都合法即可。</p><p>暴力实现它当然会 TLE。</p><p>注意到我们可以用线段树去维护区间加区间最小值，直接做即可。</p></details><h3 id=ur-12实验室外的攻防战>【UR #12】实验室外的攻防战
<a class=header-anchor href=#ur-12%e5%ae%9e%e9%aa%8c%e5%ae%a4%e5%a4%96%e7%9a%84%e6%94%bb%e9%98%b2%e6%88%98></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>合法等价于此前每个顺序对此后仍为顺序对。</p><p>我们考虑设 $u_{A_p}=v_{B_p}=p$。</p><p>那么合法等价于不存在两个数 $x&lt;y$，满足 $u_x&lt;u_y\land v_x>v_y$。</p><p>考虑对每个 $y$，找到最大的 $v_x$，使得 $x&lt;y\land u_x&lt;u_y$。</p><p>显然可以直接对值域扫描线然后 BIT 维护。</p><p>总复杂度 $O(n\log n)$。</p></details><h3 id=ur-12密码锁>【UR #12】密码锁
<a class=header-anchor href=#ur-12%e5%af%86%e7%a0%81%e9%94%81></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>结论：竞赛图缩点后形如一条链。</p><p>枚举那个强连通分量，期望容易表示成</p><p>$$\sum_{A\neq\varnothing}g(A)\sum_{B\cap C=\varnothing,B\cup C=U-A}f(B,A)f(A,C)f(B,A)$$</p><p>其中 $g(A)$ 表示 $A$ 为强连通分量的概率，而 $f(A,B)$ 为 $A$ 到 $B$ 均为单向边的方案数。</p><p>这个方法不够优秀。</p><p>其实，我们可以直接写成</p><p>$$\sum_{A\neq\varnothing}f(A,U-A)$$</p><p>理由是直接枚举链上的一个非空前缀。</p><p>考虑枚举 $A$ 与 $S-A$ 之间的特殊边集，那么我们得到若干条限制：$[i\in A]=[j\in A]$ 或者 $[i\notin A]=[j\notin A]$。</p><p>连完边后，得到若干个联通块。</p><p>如果某个联通块不合法，肯定无贡献。</p><p>否则，每个联通块内部的 $\in A$ 情况恰有 $2$ 种。</p><p>我们用一个背包计算出每种 $|A|$ 方案对应的概率，然后再统计那些非特殊的边所带来的贡献。</p><p>这样单轮复杂度即为 $O(n^2)$。</p><p>总复杂度 $O(n^22^m)$，松一松就能过了。</p><p>如果直接把每个联通块的状态指数级做一遍，最后再背包，复杂度即为 $O(n2^m+n^2)$。</p></details><h3 id=ur-12a-1--b-problem>【UR #12】a^-1 + b problem
<a class=header-anchor href=#ur-12a-1--b-problem></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>题目可以转化成若干次给定 $(A,B,C,D)$ 询问 $\sum_j\frac{Aa_j+B}{Ca_j+D}$。</p><p>判掉边界情况，就是给定 $x$ 询问 $\sum_j\frac{1}{a_j+x}$。</p><p>这个东西，我们分治 FFT 求出分子分母然后多点求值就好了。</p><p>代码的话，狗都不写好吧。</p><p>虽然就是拉个板子的难度但是多点求值还是太混乱邪恶了，因此鸽子。</p></details><h3 id=ur-13yist>【UR #13】Yist
<a class=header-anchor href=#ur-13yist></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>考虑倒序操作，我们从大到小加入一个元素 $x$。</p><p>找到往前往后第一个 $&lt;x$ 的数，查询此段区间内 $\ge x$ 的数的数目即可。</p><p>直接做复杂度是 $O(nq\log n)$ 的。</p><p>使用 BIT + 并查集，卡卡常就可以冲过去了。</p></details><h3 id=ur-13ernd>【UR #13】Ernd
<a class=header-anchor href=#ur-13ernd></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>设 $f_p$ 表示从 $p$ 开始接所能拿到的最大答案。</p><p>设 $h(u,v)$ 表示 $u$ 能否赶上 $v$，即 $h(u,v)=[b_v-b_u\ge|a_u-a_v|]=[a_v-b_v\le a_u-b_u\land a_u+b_u\le a_v+b_v]$。</p><p>设 $r_u$ 表示从 $u$ 开始最多全连到谁，即 $r_u=\max{p|u\le p\le n,\forall_{u\le j&lt;p}h(j,j+1)=1}$。</p><p>那么我们有转移</p><p>$$f_p=\max_{p\le q\le r_p}{(q-p+1)^2+\max_{q&lt;t\land h(q,t)=1}f_t}$$</p><p>设 $g_p=\max_{p&lt;t\land h(p,t)=1}f_t$，且不存在时为 $0$。</p><p>那么就是</p><p>$$f_p=(p-1)^2+\max_{p\le q\le r_p}{-2qp+(q^2+2q+g_q)}$$</p><p>由于 $y=x^2$ 是凸的，所以在 $g_p$ 的定义处，我们可以改定义成</p><p>$$g_p=\max_{r_p&lt;t\land h(p,t)=1}f_t$$</p><p>容易验证最终答案不会改变。</p><p>那么，我们可以考虑每次把一段 $r_p$ 相同的区间的 $g$ 一起计算出来，然后斜率优化算出区间的 $f$，继续更新前面的答案。</p><p>那么问题在于如何计算 $g$。</p><p>由于限制是三维的，我们可以对下标维进行 cdq 分治，做到 $O(n\log^2n)$ 的总复杂度。极限卡常或许能过，不过意义不大。</p><p>但是真的必须如此吗？</p><p>注意到 $h(u,v)=[[a_u-b_u,a_u+b_u]\subseteq[a_v-b_v,a_v+b_v]]$，因此同一个连续段对应的区间是一种包含的关系，$f$ 也是单调的，$g$ 也是单调的。</p><p>然后就不会了。开摆，贺题解。</p><p>草怎么直接用单个 BIT 维护是对的啊。这题解写的个什么东西。<img src=/qqimg/fn alt=/fn class=myimg><img src=/qqimg/fn alt=/fn class=myimg><img src=/qqimg/fn alt=/fn class=myimg></p><p>哦，就，如果 $[a_u-b_u,a_u+b_u]\subseteq[a_v-b_v,a_v+b_v]$，那么必然有 $b_u&lt;b_v$，从而 $u&lt;v$？</p><p>大意失荆州，直接按 $a-b$ 从小到大排序然后直接转移就好了，甚至 $g$ 的定义都不必改，对每个连续段的凸壳可以同时维护。</p><p>总复杂度 $O(n\log n)$。</p></details><h3 id=ur-13sanrd>【UR #13】Sanrd
<a class=header-anchor href=#ur-13sanrd></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>假设当前数是 $n$，所得的数是 $p$。</p><p>那么，$p$ 显然就是 $n$ 的<strong>非严格次大质因子</strong>，当不存在时即为 $0$。</p><p>考虑由于是求前缀和，不妨枚举答案，然后统计方案数，我们有</p><p>$$\sum_{p\in P}p\sum_{p\le q,q\in P}S(\lfloor n/pq\rfloor,p)$$</p><p>其中 $S(x,p)$ 表示 $1\sim x$ 中有多少数满足所有质因子均不大于 $p$。也即所谓「质数前缀统计」。</p><p>所有在考虑范围内的 $S(x,p)$ 数目大致是</p><p>$$\int_1^{\sqrt n}\sqrt{\frac nx}\operatorname{d}x/\log n=O(n^{3/4}/\log n)$$</p><p>的。甚至可以分析一个更紧的界，</p><p>$$(\int_1^{n^{1/3}}\sqrt{\frac nx}\operatorname{d}x+\int_{n^{1/3}}^{\sqrt n}\frac n{x^2}\operatorname{d}x)/\log n=O(n^{2/3}/\log n)$$</p><p>不过这没啥用，因为后面还是得用到 $O(n^{3/4}/\log n)$ 级别的 $S$。</p><p>而对于 $S(x,p)$ 的计算，假设我们把 $1\sim\sqrt n$ 内的质数依次称为 $p_1,p_2,\dots,p_m$，那么我们就有</p><p>$$S(x,p_k)=S(x,p_{k-1})+S(\lfloor x/p_k\rfloor,p_k)$$</p><p>于是直接 dp 即可。只用记录 $p_k^2&lt;x$ 的状态，因为否则 $p_k^2\ge x$ 总有</p><p>$$S(x,p_k)=S(x,p_{k-1})+\lfloor x/p_k\rfloor$$</p><p>一直递归到某个 $p_j^2&lt;x$ 为止。这个可以直接对每个 $x$ 数论分块来实现。</p><p>对于 $p_k^2&lt;x$ 的状态，一共只有 $O(n^{3/4}/\log n)$ 种。</p><p>我们接下来只用考虑每种 $S(x,p)$ 可能出现几次。</p><p>显然即为</p><p>$$\sum_{\lfloor\frac{n}{pq}\rfloor=x,q\ge p}[q\in P]=\sum_{\lfloor\frac{n}{p(x+1)}\rfloor&lt;q\le\lfloor\frac{n}{px}\rfloor,q\ge p}[q\in P]$$</p><p>所以我们还要快速统计出形如</p><p>$$\sum_{j=1}^n[j\in P]$$</p><p>的信息，其中 $n$ 取遍块处点值。</p><p>这个东西，我们考虑到所有 $n$ 以内的合数均有一个 $\le p_m$ 的质因子，所以我们做一个容斥，转化为</p><p>$$\sum_{j=1}^n[j\in P]=m+Q(n,p_1)-1\quad(n\ge p_m)$$</p><p>其中 $Q(n,p_k)$ 表示 $1\sim n$ 中和 $p_k\sim p_m$ 均互质的数的个数。</p><p>然后同样递推就好了。</p><p>$$Q(x,p_k)=Q(x,p_{k+1})-Q(\lfloor x/p_k\rfloor,p_{k+1})$$</p><p>同样的，当 $x\le p_k^2$ 时，有</p><p>$$Q(x,p_k)=Q(x,p_{k+1})-\lfloor x/p_k\rfloor$$</p><p>于是类似实现即可。</p><p>总复杂度 $O(n^{3/4}/\log n)$。</p><p>然后就 TLE 了。</p><p>这种递推过程中由于出现了 $\lfloor x/p_k\rfloor$，不能方便地通过求前缀和优化，这部分复杂度达到了 $O(n^{3/4})$，而数论分块的常数又很大，于是就 T 了。</p><p>不过这种形式本来就不好做，使用 BIT 维护的常数也很大。</p><p>摆了。</p></details><h3 id=ur-14最强跳蚤>【UR #14】最强跳蚤
<a class=header-anchor href=#ur-14%e6%9c%80%e5%bc%ba%e8%b7%b3%e8%9a%a4></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>完全平方数的限制一般可以通过划分等价类解决。</p><p>规定两个正整数 $a,b$ 同属一个等价类，当且仅当存在正整数 $c,p,q$ 满足 $a=cp^2\land b=cq^2$。每个等价类内最小的元素称为代表元，其同时也是一个通用的 $c$。</p><p>对这道题目，我们设一个点的权值为其到根的连接的边权乘积，那么两个点之间路径合法等价于其同属一个等价类。</p><p>不过这并没有什么卵用，因为哪怕是等价类的代表元其值域仍旧很大。。。</p><p>注意到这个和异或很像，我们质因数分解，然后给每个质数一个随机权值，改成异或即可。</p><p>唯一的问题在于质因数分解，这个可以先筛出 $\sqrt n$ 以内的质数然后再做。哈希时直接 <code>mt19937_64</code> 即可。</p></details><h3 id=ur-14人类补完计划>【UR #14】人类补完计划
<a class=header-anchor href=#ur-14%e4%ba%ba%e7%b1%bb%e8%a1%a5%e5%ae%8c%e8%ae%a1%e5%88%92></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>显然合法的图形如一颗基环树。</p><p>然后权值就是 $2^{|V|-\text{叶子节点个数}}$。</p><p>我们发现这个权值很有特点，不妨枚举点集 $A$，求出有多少点集 $V$ 边集 $E$ 满足合法且 $A$ 均<strong>不是</strong> $V$ 的叶子。</p><p>这个不是很行，没法直接算。考虑一些小技巧。</p><p>考虑设 $f(V,A)$ 为 $V$ 合法且 $A$ 中<strong>均是</strong>叶子的方案数。</p><p>设 $g(V,A)$ 为 $V$ 合法且 $A$ 中<strong>恰是</strong>叶子的方案数。</p><p>那么答案即</p><p>$$\sum_{V,A}g(V,A)2^{|V|-|A|}$$</p><p>而我们有</p><p>$$f(V,A)=\sum_{A\subseteq B}g(V,B)$$</p><p>于是作子集反演，我们得到</p><p>$$g(V,A)=\sum_{A\subseteq B}(-1)^{|B|-|A|}f(V,B)$$</p><p>关键在于 $f(V,A)$ 怎么求。</p><p>考虑到就是 $A$ 中节点随便往 $V-A$ 中连一条边，我们只用求出 $V-A$ 集合的基环树数目即可。</p><p>总而言之，问题被转化为了对每个 $V$ 求其对应基环树数目 $h(V)=f(V,\varnothing)$。</p><p>设 $T(A)$ 为 $A$ 集合生成树的数目，$C(A)$ 为 $A$ 集合形成的环数。前者可以矩阵树定理计算，后者可以暴力 dp 直接得到，复杂度且按下不表。</p><p>考虑枚举环 $A$ 的形态，对每个环上的点和环外部分建立集合幂级数，那么就是对 $|A|$ 个集合幂级数求子集卷积，暴力实现的复杂度为 $O(|A|(n-|A|)^22^{n-|A|})$ 的。</p><p>总复杂度即为</p><p>$$O(\sum_k\binom nkk(n-k)^22^{n-k})=O(n^33^n)$$</p><p>不像是能过的样子。</p><p>仔细想想，我们真的要枚举 $A$ 集合中每个点对应的树集合的集合幂级数吗？</p><p>我们可以直接对 $A$ 集合外的每棵树枚举其所连的父亲，也即环上某个节点，合并时即为将 $2^{n-|A|}$ 个集合做子集卷积。</p><p>这个可以用半半在线卷积直接做到 $O((n-|A|)^22^{n-|A|})$。</p><p>总复杂度于是即为 $O(n^23^n)$。<del>当然还是过不去</del>。</p><p>考虑怎么继续优化。</p><p>考虑直接<strong>不单独枚举环的形态</strong>，而是<strong>直接对基环树按环的顺序 dp</strong>，每次加入一颗子树，而开始时子树的根应当为环上最小点。</p><p>那么 dp 状态中可以记录环上开头、末尾元素以及当前点集，从而形如</p><p>$$t(p,q,A)\leftarrow[\text{exist edge }(o,p)][p>q][p\in B]t(o,q,A-B)T(B)$$</p><p>$$h(A)\leftarrow\frac12[\text{exist edge }(p,q)]t(p,q,A)$$</p><p>$$h(A)\leftarrow-\frac{|A|-1}2T(A)$$</p><p>除以二是因为一个环可能被正反算两遍。然后计算答案时可能出现一条边被视作环的情况，这应当被排除，故作容斥。</p><p>暴力转移的复杂度是 $O(n^33^n)$ 的。</p><p>但由于子集卷积可以优化，每次把暴力卷积换成子集卷积，复杂度即可做到 $O(n^52^n)$。</p><p><del>$n^5$ 比 $2^n$ 还大，怎么会是呢。</del></p><p>注意到对于每个点 $p$，其对应的集合幂级数可以预处理，而每个 $t(p,q,A)$ 可以同时按 $|A|$ 占位元顺序使用半半在线卷积转移。</p><p>这样转移的复杂度就在于枚举 $q,o,p$ 然后枚举占位元进行对应位置卷积，复杂度才为 $O(n^52^n)$。</p><p>仔细观察，容易发现我们的 $q$ 可以在最外层进行枚举，内部转移时可以将关于一个 $p$ 可以合并的状态 $o$ 都压在一起，这样每次转移时就不用枚举 $o$ 了。</p><p>这样的时间复杂度即为 $O(n^42^n)$，空间复杂度即为 $O(n^22^n)$。</p><p>一种有效的卡常方法是减少 FMT 次数，直接对集合幂级数操作，最后再 FMT 回来。</p><p>最后我们再看最终答案的计算。</p><p>答案为</p><div>$$
\begin{aligned}
&\sum_{A\subseteq V}2^{|V|-|A|}g(V,A)
\\=&\sum_{A\subseteq B\subseteq V}2^{|V|-|A|}(-1)^{|B|-|A|}f(V,B)
\\=&\sum_{B\subseteq V}2^{|V|}(-1)^{|B|}f(V,B)\sum_{A\subseteq B}(-\frac12)^{|A|}
\\=&\sum_{A\subseteq V}2^{|V|-|A|}(-1)^{|A|}f(V,A)
\\=&\sum_{A\cap B=\varnothing}2^{|B|}h(B)\prod_{p\in A}-\sum_{q\in B}[\text{exist edge }(p,q)]
\\=&\sum_B2^{|B|}h(B)\sum_{A\subseteq U/B}\prod_{p\in A}-\sum_{q\in B}[\text{exist edge }(p,q)]
\\=&\sum_A2^{|A|}h(A)\prod_{p\in U/A}(1-\sum_{q\in A}[\text{exist edge }(p,q)])
\end{aligned}
$$</div><p>于是该部分暴力即可做到 $O(n^22^n)$。</p><p>咋还卡 <code>long long</code> 空间的。/fn</p><p>然后就 $\rm70pts$ 了。</p><p>考虑怎么继续优化复杂度。</p><p>核心仍在于 $h$ 的计算。</p><p>考虑先统计基环内向树森林数目，然后通过集合 $\ln$ 求出基环内向树数目，进而推出基环树数目。</p><p>考虑构造双射：对集合内每个点往其余点随意连一条边，容易发现每种连边方案对应了一颗基环内向树。</p><p>对取 $\ln$ 后的每个联通块，考虑其和基环树数目，如果环是一个重边则会被统计恰好 $1$ 次，否则会被统计 $2$ 次。</p><p>因此同样去掉树的情况再除二即可。</p><p>时间复杂度 $O(n^32^n)$，空间复杂度 $O(n2^n)$。</p><p>瓶颈在矩阵树定理上，使用逐点牛顿迭代法计算生成树个数即可优化到 $O(n^22^n)$。</p></details><h3 id=ur-14思考熊>【UR #14】思考熊
<a class=header-anchor href=#ur-14%e6%80%9d%e8%80%83%e7%86%8a></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>二进制分组板子。Unknown v2。</p><p>考虑线段树上二进制分组，对一个节点其为合并好的当且仅当下一个达到其长度的区间已经存在，复杂度可以均摊。</p><p>然后对每个节点考虑如何支持 $O(n^{1+\varepsilon})$ 预处理 $O(n^{\varepsilon})$ 查询。</p><p>我们可以建出虚树，对虚树上每个节点进行换根 dp，然后尝试在查询时快速找到该节点信息最小在哪个子树中、最大在哪个子树外。</p><p>这个可以用 dfn 序 + ODT 直接维护。</p><p>然后要求快速查询点对间距离，这个可以树剖维护。</p><p>总复杂度 $O(n+q\log^2n)$。</p><p>被卡常了，$\rm 97pts$，开摆。</p></details><h3 id=共价大爷游长沙>共价大爷游长沙
<a class=header-anchor href=#%e5%85%b1%e4%bb%b7%e5%a4%a7%e7%88%b7%e6%b8%b8%e9%95%bf%e6%b2%99></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>考虑给每条路径一个 $0\sim2^{64}-1$ 内的随机权值，而一条边的权值为经过其的路径的权值异或。</p><p>我们判定一条边合法，当且仅当其与目前所有路径权值的异或相等。正确率容易分析。</p><p>LCT 维护一下即可。</p><p>复杂度 $O(n+q\log n)$。</p></details><h3 id=uer-6票数统计>【UER #6】票数统计
<a class=header-anchor href=#uer-6%e7%a5%a8%e6%95%b0%e7%bb%9f%e8%ae%a1></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>如果 $x\neq y$，那么显然其中哪条成立易知。</p><p>而对于 $x=y$ 的情况，其表示前 $x$ 个或后 $x$ 个均通过，因此该种限制只用保留最大一项。</p><p>暴力枚举一下是前 $x$ 个均通过，还是后 $x$ 个均通过，还是均满足，暴力容斥一下求出答案。不存在 $x=y$ 的情况时不妨直接记为 $x=0$。当 $2x\ge n$ 时要特殊处理。</p><p>接下来只用考虑每种已经唯一确定的限制均合法的情况。</p><p>每种限制表示前 / 后 $a$ 个人中恰有 $b$ 个支持。</p><p>考虑枚举一下总支持人数，那么每条信息相当于是每个前缀中恰有若干个支持，也就是每个区间中恰有若干个支持，直接一个组合数即可算出方案数。</p><p>总复杂度 $O(nm)$。</p></details><h3 id=uer-6寻找罪犯>【UER #6】寻找罪犯
<a class=header-anchor href=#uer-6%e5%af%bb%e6%89%be%e7%bd%aa%e7%8a%af></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>草这个原来真可以 2-SAT，我还以为不行。。。</p><p>$$\forall(i,j,0),x_i=1\rightarrow x_j=0,x_j=1\rightarrow x_i=0$$</p><p>$$\forall(i,j,1),x_i=1\rightarrow x_j=1,x_j=0\rightarrow x_i=0$$</p><p>$$\forall(i,j,0)(i,k,0),j\neq k,x_j=1\rightarrow x_k=0,x_k=1\rightarrow x_j=0$$</p><p>$$\forall(i,j,0)(i,k,1),x_j=1\rightarrow x_k=1,x_k=0\rightarrow x_j=0$$</p><p>$$\forall(i,j,1)(i,k,1),j\neq k,x_j=0\rightarrow x_k=1,x_k=0\rightarrow x_j=1$$</p><p>暴力建图点数目是 $O(n)$ 的，边数目是 $O(n^2)$ 的。</p><p>使用前缀优化建图即可优化到 $O(n)$ 的点数和边数，总复杂度 $O(n)$。</p></details><h3 id=uer-6逃跑>【UER #6】逃跑
<a class=header-anchor href=#uer-6%e9%80%83%e8%b7%91></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>方差是什么？</p><p>$$\operatorname V!X=\operatorname E!X^2-(\operatorname E!X)^2$$</p><p>于是只用求出 $\operatorname E!X$ 和 $\operatorname E!X^2$ 即可。</p><p>怎么求呢？</p><p>先考虑求 $\operatorname E!X$ 的部分。</p><p>考虑反向统计贡献，我们统计每个位置有多少种方案被走上至少一次。直接 dp 记录每个时刻当前位置，每个 dp 复杂度 $O(n^3)$。由于要枚举做出贡献的点，总复杂度 $O(n^5)$。$\operatorname E!X^2$ 也可以类似地做到 $O(n^7)$。</p><p>这样还不够。考虑怎么继续优化。</p><p>考虑容斥，容易得到在 $n$ 时刻恰好第一次走到 $(x,y)$ 的方案数满足</p><p>$$D_{x,y,n}=A_{x,y,n}-\sum_{t>0}A_{0,0,t}D_{x,y,n-t}$$</p><p>其中 $A_{x,y,t}$ 为花 $t$ 步从 $(0,0)$ 走到 $(x,y)$ 的方案数。</p><p>$$A_{x,y,t}=\sum_{a,b}[2(a+b)=t-x-y]\binom{t}{a+x,a,b+y,b}w_1^{a+x}w_2^aw_3^{b+y}w_4^b$$</p><p>在前 $n$ 个时刻中 $(x,y)$ 被走到至少一次的方案数为</p><p>$$F_{x,y,n}=(w_1+w_2+w_3+w_4)F_{x,y,n-1}+D_{x,y,n}$$</p><p>故可在 $O(n^4)$ 内算出所有 $F_{x,y,n}$，也就算出了 $\operatorname E!X$。</p><p>对于求 $\operatorname E!X^2$ 的过程，我们枚举点对 $(x_1,y_1)(x_2,y_2)$。$(x_1,y_1)=(x_2,y_2)$ 的情况是平凡的，我们接下来考虑 $(x_1,y_1)\neq(x_2,y_2)$ 的情况。</p><p>枚举第一个到达的是哪个点，譬如 $(x_1,y_1)$，然后容易考虑其下一步往 $(x_2,y_2)$ 走的情况。但由于实际上可能会出现先到达 $(x_2,y_2)$ 的情况，故应当对此做容斥。由于子问题还会这么干，容易做出一个链状的「交替容斥」。也即</p><div>$$
\sum_{t_1\le t_2}D_{x_1,y_1,t_1}F_{x_2-x_1,y_2-y_1,n-t_2}[z^{t_2-t_1}]\frac{1}{1-\sum_{a,b}D_{x_2-x_1,y_2-y_1,a}D_{x_1-x_2,y_1-y_2,b}z^{a+b}}
\\-\sum_{t_1\le t_2}D_{x_1,y_1,t_1}F_{x_1-x_2,y_1-y_2,n-t_2}[z^{t_2-t_1}]\frac{\sum_aD_{x_2-x_1,y_2-y_1,a}z^a}{1-\sum_{a,b}D_{x_2-x_1,y_2-y_1,a}D_{x_1-x_2,y_1-y_2,b}z^{a+b}}
\\+\sum_{t_1\le t_2}D_{x_2,y_2,t_1}F_{x_1-x_2,y_1-y_2,n-t_2}[z^{t_2-t_1}]\frac{1}{1-\sum_{a,b}D_{x_2-x_1,y_2-y_1,a}D_{x_1-x_2,y_1-y_2,b}z^{a+b}}
\\-\sum_{t_1\le t_2}D_{x_2,y_2,t_1}F_{x_2-x_1,y_2-y_1,n-t_2}[z^{t_2-t_1}]\frac{\sum_aD_{x_1-x_2,y_1-y_2,a}z^a}{1-\sum_{a,b}D_{x_2-x_1,y_2-y_1,a}D_{x_1-x_2,y_1-y_2,b}z^{a+b}}
$$</div><p>这个形式太丑了。</p><p>我们设生成函数</p><p>$$D_{x,y}(z)=\sum_tD_{x,y,t}z^t$$</p><p>$$F_{x,y}(z)=\sum_tF_{x,y,t}z^t$$</p><p>稍微化一下，转成</p><p>$$
[z^n]\frac{D_{x_1,y_1}(F_{x_2-x_1,y_2-y_1}-D_{x_2-x_1,y_2-y_1}F_{x_1-x_2,y_1-y_2})+D_{x_2,y_2}(F_{x_1-x_2,y_1-y_2}-D_{x_1-x_2,y_1-y_2}F_{x_2-x_1,y_2-y_1})}{1-D_{x_2-x_1,y_2-y_1}D_{x_1-x_2,y_1-y_2}}
$$</p><p>再设</p><p>$$U_{x,y}=\frac{F_{x,y}-D_{x,y}F_{-x,-y}}{1-D_{x,y}D_{-x,-y}}$$</p><p>则即</p><p>$$[z^n] (D_{x_1,y_1}U_{x_2-x_1,y_2-y_1}+D_{x_2,y_2}U_{x_1-x_2,y_1-y_2})$$</p><p>由于</p><p>$$(w_1+w_2+w_3+w_4)^n\operatorname E!X^2=[z^n]\sum_{(x_1,y_1)\neq(x_2,y_2)}(D_{x_1,y_1}U_{x_2-x_1,y_2-y_1}+D_{x_2,y_2}U_{x_1-x_2,y_1-y_2})+\sum_{x,y}F_{x,y,n}$$</p><p>于是我们其实可以直接把每个 $D_{x_1,x_2}$ 叠在一起，每个 $U_{x_2-x_1,y_2-y_1}$ 叠在一起，最后再计算贡献。</p><p>于是计算 $\operatorname{E}!X^2$ 部分答案的复杂度即可做到 $O(n^3)$。</p><p>总复杂度 $O(n^4)$，瓶颈在计算 $A,D,U$ 上。如果允许 FFT 则为 $O(n^3\log n)$。</p></details><h3 id=unr-1争夺圣杯>【UNR #1】争夺圣杯
<a class=header-anchor href=#unr-1%e4%ba%89%e5%a4%ba%e5%9c%a3%e6%9d%af></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>考虑建出笛卡尔树，每次统计子树中经过根节点的区间的贡献。</p><p>容易发现每个贡献均形如区间加等差数列。</p><p>拿两个差分数组分别维护一下斜率和截距即可，最后做一次前缀和得到结果。</p><p>总复杂度 $O(n)$。</p></details><h3 id=unr-1合唱队形>【UNR #1】合唱队形
<a class=header-anchor href=#unr-1%e5%90%88%e5%94%b1%e9%98%9f%e5%bd%a2></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>推完后才发现自己读错题了。</p><p>原来询问的小写字母串中会有重复字符吗。大受震撼。</p><p>同样删除无效限制，那么不会多于 $n-m+1$ 个限制。</p><p>min-max 反演一下，期望最小步数转化为每个子集完全覆盖的期望步数，暴力枚举子集，复杂度 $O^*(2^{n-m})$。当 $m\ge n/2$ 时可以这么干。</p><p>考虑 $m$ 比较小的情况。</p><p>同样 min-max 反演，把柿子列出来，为</p><div>$$
\operatorname{E}(\min_{j\in T}\text{time when }[j,j+m)\text{ is ok})
\\=\sum_{S\subseteq T,S\neq\varnothing}(-1)^{|S|-1}\operatorname{E}(\max_{j\in S}\text{time when }[j,j+m)\text{ is ok})
\\=\sum_{S\subseteq T,S\neq\varnothing}(-1)^{|S|-1}a_{|\text{classes to solve all in }S|}
$$</div><p>其中 $a_n=AH_n$，$A$ 为总课程数，$H_n$ 为调和数。</p><p>注意到每个 $S_j$ 对应的课程都是一段长度为 $m$ 的区间，因此决定了新课程增加量的只有前 $m$ 个区间，直接状压即可，复杂度 $O^*(2^m)$。</p><p>具体地，我们在状态中记录下 $A$ 的大小和前 $m$ 个集合是否选择即可。</p><p>总复杂度 $O^*(1.41^n)$。</p></details><h3 id=unr-1jakarta-skyscrapers>【UNR #1】Jakarta Skyscrapers
<a class=header-anchor href=#unr-1jakarta-skyscrapers></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>不妨 $a\le b$。</p><p>首先，如果 $\gcd{a,b}\nmid c\lor b&lt;c$，那么无解。</p><p>否则，我们不妨先令</p><p>$$a\leftarrow a/\gcd{a,b},b\leftarrow b/\gcd{a,b},c\leftarrow c/\gcd{a,b}$$</p><p>则应有 $a\perp b$，$a,c\le b$。</p><p>考虑尝试构造出 $1$。</p><p>考虑欧几里得算法，已知 $a,b$，怎么在 $O(\log(b/a))$ 步内构造出 $b\bmod a$。</p><p>我们考虑依次构造 $b-a,b-2a,2a,b-4a,4a,\dots,b-2^ka$，且 $2^{k+1}a>b$。</p><p>然后我们再对 $b-2^ka$ 依次尝试减去 $2^{k-1}a,2^{k-2}a,\dots,2a,a$，如果可减就减。最后所得即为 $b\bmod a$。</p><p>这样每步复杂度 $O(\log(b/a))$，迭代共 $O(\log n)$ 轮，总复杂度即为 $O(\log n)$。</p><p>当某时刻 $a=1$，直接结束当前过程。</p><p>然后我们就在 $O(\log n)$ 步内构造出了 $1$。</p><p>然后我们取出最开始的 $b$，类似地依次构造 $b-1,b-2,2,b-4,4,\dots,b-2^k$，直至 $b-2^{k+1}&lt;c$。</p><p>接下来再每步尝试减去 $2^{k-1},2^{k-2},\dots,1$，这样又只花了 $O(\log n)$ 步。</p><p>总步数级别 $O(\log n)$，可以通过。</p></details><h3 id=ur-15奥林匹克五子棋>【UR #15】奥林匹克五子棋
<a class=header-anchor href=#ur-15%e5%a5%a5%e6%9e%97%e5%8c%b9%e5%85%8b%e4%ba%94%e5%ad%90%e6%a3%8b></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>如果 $k=1$，显然无解。</p><p>如果 $k=2$，有解当且仅当 $n=1\lor m=1$，可以直接错位构造。</p><p>如果 $k\ge3$，我们这么构造：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-6-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-6-1>1</a></span><span>0101010101...
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-6-2><a style=outline:none;text-decoration:none;color:inherit href=#hl-6-2>2</a></span><span>0101010101...
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-6-3><a style=outline:none;text-decoration:none;color:inherit href=#hl-6-3>3</a></span><span>1010101010...
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-6-4><a style=outline:none;text-decoration:none;color:inherit href=#hl-6-4>4</a></span><span>1010101010...
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-6-5><a style=outline:none;text-decoration:none;color:inherit href=#hl-6-5>5</a></span><span>0101010101...
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-6-6><a style=outline:none;text-decoration:none;color:inherit href=#hl-6-6>6</a></span><span>0101010101...
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-6-7><a style=outline:none;text-decoration:none;color:inherit href=#hl-6-7>7</a></span><span>.............
</span></span></code></pre></div><p>取一个 $n\times m$ 的左上角子矩形，其中 $2|m$ 或 $2\nmid n$，总有 $0,1$ 数目相等或 $0$ 比 $1$ 多 $1$ 个，且显然不存在三子连珠。</p><p>然后就做完了。</p></details><h3 id=ur-15奥林匹克环城马拉松>【UR #15】奥林匹克环城马拉松
<a class=header-anchor href=#ur-15%e5%a5%a5%e6%9e%97%e5%8c%b9%e5%85%8b%e7%8e%af%e5%9f%8e%e9%a9%ac%e6%8b%89%e6%9d%be></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>先考虑树的情况。</p><p>每条边被正反走过一次，我们不妨定一个根来做。</p><p>首先边权都得是偶数，我们不妨除二。</p><p>我们假设「更换起始边后两序列相同」得到的是不同的序列。</p><p>假设 $\deg(p)=\sum_sw(p,s)$</p><p>假设 $f_p$ 为 $p$ 子树内从 $p$ 开始走的选法总数目。</p><p>则</p><p>$$f_p=\binom{\deg(p)}{w(p,s_1),w(p,s_2),\dots,w(p,s_m)}\prod_s(2w(p,s))!\binom{w(p,s)+\deg(s)-1}{w(p,s)-1}f_s$$</p><p>最后由于是圆排列，答案即为 $f_{\mathrm{root}}/\deg(\mathrm{root})$。</p><p>稍微移一下系数就可以发现，设 $d_p=\sum_qw(p,q)$，则答案即为</p><p>$$(\prod_e\frac{(2w_e)!}{w_e!(w_e-1)!})(\prod_p(d_p-1)!)$$</p><p>然后我们发现我们是憨憨：直接用 BEST 定理就可以得到相同的结论；因为每条树边可以拆成一对有向边，枚举一下把哪些边拆成其中一个方向，就可以用 BEST 定理得到同样的结论了。</p><p>接下来考虑基环树的情况。</p><p>显然环边奇偶性相同，树边均偶数。</p><p>假设一个环上的点两侧的边数分别为 $t_1,t_2$，那么该点一定恰好被从环上进入 $\frac{t_1+t_2}{2}$ 次。设为 $r_p$。</p><p>由于是环排列，我们总不妨令第一步不走入子树。故对于这个点的子树，我们可以类似于之前的方法计算出贡献 $f_p\binom{r_p+\deg(p)-1}{\deg(p)}$。</p><p>然后就是环上有多少种环排列的走法的问题了。</p><p>我们假设环上各边数目依次为 $t_1,t_2,\dots,t_m$。</p><p>注意到值域很小，考虑暴力枚举有某条边有多少正着走的方案，从而得到每条边有多少个正 / 反走的方案。</p><p>假设有 $x_1,x_2,\dots,x_m$ 个正走的，$y_1,y_2,\dots,y_m$ 个倒走的，其中 $x_j+y_j=t_j,x_j+y_{j+1}=r_j$，由 BEST 定理，方案数即</p><div>$$\begin{vmatrix}r_1&-x_1\\-y_1&r_2&-x_2\\&-y_2&r_3&-x_3\\&&-y_3&\ddots&\ddots\\&&&\ddots&r_{m-1}\end{vmatrix}\prod_j(r_j-1)!$$<div><p>注意到</p><div>$$\begin{vmatrix}r_1&-x_1\\-y_1&r_2&-x_2\\&-y_2&r_3&-x_3\\&&-y_3&\ddots&\ddots\\&&&\ddots&r_{m-1}\end{vmatrix}=r_1\begin{vmatrix}r_2&-x_2\\-y_2&r_3&-x_3\\&-y_3&\ddots&\ddots\\&&\ddots&r_{m-1}\end{vmatrix}-x_1y_1\begin{vmatrix}r_3&-x_3\\-y_3&\ddots&\ddots\\&\ddots&r_{m-1}\end{vmatrix}$$<div><p>从而可以 $O(n)$ 递推。</p><p>总复杂度 $O(nt)$，可以通过。</p></details><h3 id=基础数据结构练习题>基础数据结构练习题
<a class=header-anchor href=#%e5%9f%ba%e7%a1%80%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%bb%83%e4%b9%a0%e9%a2%98></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>考虑线段树维护，每个节点维护区间最大最小值和区间和。</p><p>如果区间全部相同，可以转化为区间加的 tag。</p><p>如果区间最值相差 $1$ 且开根后不同，则也打区间加的 tag。</p><p>否则暴力下传。</p><p>我们猜测这么做复杂度是对的。（看着就很对的样子！）</p><p>简单证明一下，拿 $\sum\log\log\text{区间极差}$ 做势能，每次区间加带来的抬升量是 $O(\log n\log\log v)$ 的，初值是 $O(n\log\log v)$ 的，每次暴力下传降低量是 $\Omega(1)$ 的，感觉复杂度毛估估就很对！</p><p>这样总复杂度即为 $O((n+q\log n)\log\log v)$。</p></details><h3 id=ur-16破坏发射台>【UR #16】破坏发射台
<a class=header-anchor href=#ur-16%e7%a0%b4%e5%9d%8f%e5%8f%91%e5%b0%84%e5%8f%b0></a></h3><p><a href=https://www.cnblogs.com/myee/p/uoj241.html title=题解链接>题解链接
</a>。</p><h3 id=ur-16破坏蛋糕>【UR #16】破坏蛋糕
<a class=header-anchor href=#ur-16%e7%a0%b4%e5%9d%8f%e8%9b%8b%e7%b3%95></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>我们不妨先暴力求出所有交点，然后对直线进行排序。</p><p>首尾块显然不封闭，我们考虑相邻两条直线之间怎样是封闭的。</p><p>考虑维护出每条直线相对于给定直线的极角，显然其在 $(0,\pi)$ 间。不妨假设依次为 $\alpha_1,\alpha_2,\dots,\alpha_n$。</p><p>考虑 $p$ 与 $p+1$ 之间怎样是合法的。</p><p>显然封闭相当于补全上、下两个缺口。容易发现这等价于 $\exists,i\le p,j>p,,\alpha_i>\alpha_j$ 且 $\exists,i\le p,j>p,,\alpha_i&lt;\alpha_j$。</p><p>证明？<del>我不会我不会</del>。其实是好证的。</p><p>计算一下前后缀最值即做完。</p><p>为了防止掉精，我直接使用了极角余弦值的分数形式进行比较。</p></details><h3 id=uer-7短路>【UER #7】短路
<a class=header-anchor href=#uer-7%e7%9f%ad%e8%b7%af></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>贪心题！</p><p>注意到我们总不妨只往右、下走。</p><p>考察第 $n+1$ 个格子，我们总不妨令前后选法对称。</p><p>容易证明，对于第 $n+1$ 个格子对应的类型，我们总不妨取完。</p><p>问题变成从起点走到对角线的最小代价。</p><p>考虑推进一个位置时，我们除了加上该部分代价，再加上前缀最小值的贡献。</p><p>容易证明这么贪是对的。</p><p>总复杂度 $O(n)$。</p></details><h3 id=uer-7天路>【UER #7】天路
<a class=header-anchor href=#uer-7%e5%a4%a9%e8%b7%af></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>很牛的一道题！</p><p>注意到我们可以每隔 $1.05$ 倍长度做一次，这样我们只用处理 $\log_{1.05}v$ 种长度对应的答案。</p><p>对每种长度，我们考虑双指针。由于有效的指针只有 $O(n)$ 对所以只用做 $O(n)$ 次。</p><p>现在要快速支持插入或删除一个元素，然后查询最长被覆盖的连续段长度。怎么做？</p><p>直接拿一个线段树或 <code>set</code> 维护，单次复杂度 $O(\log n)$，总复杂度 $O(n\log n\log_\alpha v)$，其中 $\alpha=1.05$。</p><p>$\log_\alpha v$ 大约是 $300$ 的样子，看上去不是很能过？</p><p>查询时由于只用得到最长值，我们可以每次仅仅查看一个值如果作为当前连续段的最大数，其向前后分别能扩展多少。</p><p>我们可以预先建出笛卡尔树，得到每个点的基于上界的边界，然后考虑快速找到基于下界的边界。</p><p>我们再建出一个小根的笛卡尔树，然后就是快速查询距离不大于某个值的最远祖先，二分单调栈即可。加上决策单调性的剪枝后常数很小。</p><p>复杂度仍为 $O(n\log n\log_\alpha v)$，由于常数很小，容易通过。</p><p>然后发现大意了，直接按两个端点搞双指针就好了。。。复杂度 $O(n\log_\alpha v)$。</p></details><h3 id=直径拆除鸡>直径拆除鸡
<a class=header-anchor href=#%e7%9b%b4%e5%be%84%e6%8b%86%e9%99%a4%e9%b8%a1></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>我们这么构造：</p><p>注意到有多条直径时具体取哪条是可以任意指定的，直径上一个节点往直径外的节点连边长度不能超过当前点离直径端点的距离。</p><p>因此我们总不妨往最靠中间的节点塞一个子结构，满足直径不大于当前直径 $-2$。</p><p>最后多余的部分可以往最后一层直径等于 $3$ 的中点嗯塞。</p><p>毛估估感觉这样是最多的，大概是 $O(n\sqrt n)$ 级别的。</p><p>然后实际上可能有的时候去掉最外面几层答案会更大，可以枚举一下去掉多少层；反正不会超过 $\sqrt n$ 层。</p><p>总复杂度 $O(n)$。</p></details><h3 id=快乐游戏鸡>快乐游戏鸡
<a class=header-anchor href=#%e5%bf%ab%e4%b9%90%e6%b8%b8%e6%88%8f%e9%b8%a1></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>我们算出路径上的最大 $w$，来确定至少要把 $w$ 刷到多少才能走。</p><p>然后考虑从 $s$ 开始刷 $w$。</p><p>我们知道刷 $w$ 的过程是个凸函数，考虑计算出每个子树的这个凸壳。</p><p>不妨离线下来，长链剖分维护出单调栈，进行启发式合并，然后直接嗯做就好了。</p><p>计算树上路径最值的部分偷了个懒，写了树上倍增，总复杂度 $O((n+q)\log n)$。</p></details><h3 id=unr-2uoj拯救计划>【UNR #2】UOJ拯救计划
<a class=header-anchor href=#unr-2uoj%e6%8b%af%e6%95%91%e8%ae%a1%e5%88%92></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>观察一下，假设实际用到了 $t$ 种颜色，只有 $t\le2$ 有意义：如果 $t\ge3$，同构的方案数共有 $k^{\underline t}$ 种（相当于做了个映射），必然为 $6$ 的倍数，于是无需统计。</p><p>因此我们分类讨论：</p><ul><li>如果 $m=0$，总方案数显然是 $k^n$。</li><li>如果 $m>0$ 且是二分图，先 $\binom k2$ 枚举选择哪两种颜色，然后二分图每个联通块有 $2$ 种选法，直接计算即可。</li><li>否则，答案模 $6$ 为 $0$。</li></ul><p>总复杂度 $O(n+m)$。</p></details><h3 id=unr-2黎明前的巧克力>【UNR #2】黎明前的巧克力
<a class=header-anchor href=#unr-2%e9%bb%8e%e6%98%8e%e5%89%8d%e7%9a%84%e5%b7%a7%e5%85%8b%e5%8a%9b></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>即选出两个不交集合，使得其异或和相等。最后减去均不选的情况即可。</p><p>我们考察不被选择的元素状态；显然其异或应当等于所有元素的总异或值；而被选择的那些元素任意的集合分割方案均是合法的。</p><p>因此，我们设</p><p>$$f(S)=\mathop{\Large\oplus}\limits_{j\in S}a_j$$</p><p>并记 $U={1,2,3,\dots,n}$，则答案即为</p><div>$$
-1+\sum_{S\subseteq U,f(S)=f(U)}2^{n-|S|}
\\=-1+[z^{\mathop\oplus_{1\le i\le n}a_i}]\prod_{1\le i\le n}(2+z^{a_i})
$$</div><p>其中幂级数乘法被定义为异或卷积。</p><p>注意到值域只有 $10^6$，考虑 FWT。</p><p>考虑 FWT 的过程，我们 FWT 时 $x\rightarrow y$ 的贡献系数为 $(-1)^{\operatorname{popcount}(x\operatorname{bitand} y)}$，因此 $2+z^a$ 对 $b$ 位置的贡献系数为 $2+(-1)^{\operatorname{popcount}(a\operatorname{bitand} b)}$。</p><p>于是我们统计出每个 $b$ 会被多少个 $a$ 做出 $3$ 的贡献，这个是可以一遍 FWT 计算得到的，复杂度 $O(v\log v)$。</p><p>然后取 $3$ 的该次幂，求出 IFWT 后的 $\mathop\oplus_{1\le i\le n}a_i$ 项结果，可以直接 $O(v)$ 解决。</p><p>总复杂度 $O(n+v\log v)$，可以轻松通过。</p></details><h3 id=unr-2积劳成疾>【UNR #2】积劳成疾
<a class=header-anchor href=#unr-2%e7%a7%af%e5%8a%b3%e6%88%90%e7%96%be></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>即求</p><p>$$\sum_{\forall1\le j\le n,1\le a_j\le n}\prod_{i=0}^{n-k}w_{\max a_{i+1\sim i+k}}$$</p><p>看上去不好做。</p><p>考虑按笛卡尔树的方法来 dp。</p><p>假设</p><p>$$f(n,m)=\sum_{\forall1\le j\le n,1\le a_j\le m}\prod_{i=0}^{n-k}w_{\max a_{i+1\sim i+k}}$$</p><p>那么，我们枚举 $a$ 中最左最大值，及其所在位置，则有</p><div>$$f(n,m)=\begin{cases}0&m=0\land n\ge k\\f(n,m-1)+\sum_{1\le p\le n}w_m^{\min\{n-k,p-1\}-\max\{0,p-k\}+1}f(p-1,m-1)f(n-p,m)&m>0\land n\ge k\\m^n&n < k \end{cases}$$</div><p>预处理一下转移系数，复杂度 $O(n^3)$。</p></details><h3 id=新年的xor>新年的XOR
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84xor></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>首先，$(2k)\oplus(2k+1)=1$。</p><p>因此 $(2k)\oplus(2k+1)\oplus(2k+2)\oplus(2k+3)=0$。</p><p>当 $n\equiv0\pmod4$ 时，$1\oplus2\oplus3\oplus\dots\oplus n=n$；特判 $n=0$，取 $0=1\oplus2\oplus3$ 即可。</p><p>当 $n\equiv1\pmod4$ 时，$2\oplus3\oplus\dots\oplus(n-1)=n$；特判 $n=1$，取 $1=2\oplus3$ 即可。</p><p>当 $n\equiv2\pmod4$ 时，$2\oplus3\oplus\dots\oplus n=n$；特判 $n=2$，取 $2=3\oplus4\oplus5$ 即可。</p><p>当 $n\equiv3\pmod4$ 时，$1\oplus2\oplus3\oplus\dots\oplus (n-1)=n$。</p><p>这样就做完了。</p></details><h3 id=新年的叶子>新年的叶子
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84%e5%8f%b6%e5%ad%90></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>首先提取出一条直径，然后把所有在任一条直径上的叶子取出。</p><p>我们找出直径中点，从其把整颗树分成 $\ge2$ 个部分。</p><p>合法等价于只有一个部分没有被完全摧毁。</p><p>我们假设各部分分别有 $a_1,a_2,\dots,a_m$ 个有效的叶子，共有 $A=\sum a$ 个叶子。</p><p>考虑使用 GF 来描述答案。</p><p>枚举最后剩下的部分以及最后一步选法，答案即为</p><p>$$(\Xi\sum_{j=1}^m\frac{A-a_j}{A}(e^{z/A}-1)^{A-a_j-1}(e^{a_jz/A}-(e^{z/A}-1)^{a_j}))&rsquo;_z(1)+1$$</p><p>设 $u=e^{z/A}$，我们只用得到</p><p>$$\sum_{j=1}^m\frac{A-a_j}{A}(u-1)^{A-a_j-1}(u^{a_j}-(u-1)^{a_j})$$</p><p>关于 $u$ 的结果即可。</p><p>仔细观察这个形式会发现该形式是可优化的；简单来说，我们考虑这么做：</p><div>$$\sum_{j=1}^m\frac{A-a_j}{A}(u-1)^{A-a_j-1}(u^{a_j}-(u-1)^{a_j})\\=-(m-1)(u-1)^{A-1}+u^{A-1}\sum_{j=1}^m\frac{A-a_j}{A}(1-1/u)^{A-a_j-1}$$</div><p>考虑解决</p><p>$$\sum_j\frac{A-a_j}{A}(1-u)^{A-a_j-1}$$</p><p>容易发现就是一个一次函数复合的形式，直接一次卷积即可搞定。</p><p>最后计算完答案后，因为可能枚举到无用叶子，还需乘上对应系数。</p></details><h3 id=ur-17滑稽树上滑稽果>【UR #17】滑稽树上滑稽果
<a class=header-anchor href=#ur-17%e6%bb%91%e7%a8%bd%e6%a0%91%e4%b8%8a%e6%bb%91%e7%a8%bd%e6%9e%9c></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>结论：最优解肯定不妨是链。</p><p>证明可以考虑如果最优解出现一对兄弟 $u,v$，那么把 $u$ 子树接到 $v$ 下面更不劣。</p><p>然后去掉所有数的与的贡献后，我们只用最小化顶部的贡献，也就是变成 $0$ 的代价。</p><p>考虑 dp，枚举每个数能通过按位与上一个 $a$ 转移到谁，最小化转移代价。</p><p>预处理一下信息即可做完。</p></details><h3 id=unr-3鸽子固定器>【UNR #3】鸽子固定器
<a class=header-anchor href=#unr-3%e9%b8%bd%e5%ad%90%e5%9b%ba%e5%ae%9a%e5%99%a8></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>首先按 $s$ 排序。</p><p>如果选择的个数 $&lt;m$ 个，那总不妨是一段连续的区间，否则不如继续在内部选。</p><p>接下来考虑 $=m$ 的情况，那么一定是选择区间中 $v$ 最大的 $m$ 个来计算贡献。</p><p>考虑从大到小枚举这最大的 $m$ 个中的最小元素，依次插入，然后枚举区间来查询即可。</p><p>粗暴实现，总复杂度 $O(nm\log n)$。</p><p>反过来枚举，逐个删除元素，使用双向链表可以优化复杂度到 $O(nm+n\log n)$。</p></details><h3 id=新年的拯救计划>新年的拯救计划
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84%e6%8b%af%e6%95%91%e8%ae%a1%e5%88%92></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>显然答案不超过 $\lfloor n/2\rfloor$，接下来我们来看构造方案。</p><p>不妨点标号从 $0$ 到 $n-1$，$n\sim 2n-1$ 是其别称。</p><p>设 $d=\lfloor n/2\rfloor$，则对 $p=0,1,2,\dots,d-1$，我们依次如下连边：$(p,p+1)(p,p+2)\dots(p,p+d)(p+d,p+d+1)(p+d,p+d+2)\dots(p+d,p+n-1)$。</p><p>容易验证构成树且边不重。</p></details><h3 id=新年的小黄鸭>新年的小黄鸭
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84%e5%b0%8f%e9%bb%84%e9%b8%ad></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>很厉害的一道题。</p><p>假设一个子树 $p$ 的答案是 $g_p$，那么考虑枚举重链底部的叶子 $t$，则有</p><p>$$g_p=\sum_{a\text{ is between }p\text{ and }t}([a\neq p\land\log_2(\operatorname{dep}(a)-\operatorname{dep}(p))\in\mathbb N]siz_a+\sum_{s\text{ is son of }a,s\text{ isn&rsquo;t between }p\text{ and }t}(g_s+siz_s))$$</p><p>后半部分贡献容易维护，考虑前半部分，我们可以直接暴力枚举合法的 $a$，容易发现总数是 $O(n\log n)$ 的。</p><p>最后线段树上 $O(n\log n)$ 次区间加，$O(n)$ 次区间查询最小值。</p><p>直接做就是 $O(n\log^2n)$ 的。</p></details><h3 id=新年的促销>新年的促销
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84%e4%bf%83%e9%94%80></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>首先送的总不妨是买的这些中费用最大的若干。</p><p>我们按费用 $p$ 排序，对每个前缀计算出在该前缀中 $t$ 元买 $k$ 袋的最小代价，往后选 $w$ 最大的若干作为送的部分即可。</p><p>总复杂度 $O(n^2m)$。</p></details><h3 id=新年的追逐战>新年的追逐战
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84%e8%bf%bd%e9%80%90%e6%88%98></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>做构造题做破防了，于是来看这题。</p><p>两个点连边当且仅当对应各维在各图上连边。</p><p>考虑各图的某个联通块 $A_1,A_2,\dots,A_m$ 所构成的子问题。</p><p>假设其中有单点，那么带来 $\prod_{k=1}^m|A_k|$ 的贡献。</p><p>否则如果 $A_1\sim A_m$ 中有 $t$ 个二分图，那么其带来 $2^{\max{0,t-1}}$ 个联通块的贡献。</p><p>假设 $n$ 个点的非单点简单联通图有 $f_n$ 的方案生成，非单点简单联通二分图有 $g_n$ 的方案生成。</p><p>那么不考虑单点时答案即为</p><p>$$\frac{\prod_{k=1}^n\sum_t\binom{m_k}{t}(f_t+g_t)2^{\binom{m_k-t}2}+\prod_{k=1}^n\sum_t\binom{m_k}{t}(f_t-g_t)2^{\binom{m_k-t}2}}{2}$$</p><p>而单点的贡献为</p><p>$$\prod_{k=1}^n\sum_t\binom{m_k}tt(f_t+[t=1])2^{\binom{m_k-t}2}-\prod_{k=1}^n\sum_t\binom{m_k}ttf_t2^{\binom{m_k-t}2}$$</p><p>这些贡献都是容易用卷积计算的，接下来即为考虑如何计算 $f$ 和 $g$。</p><p>对于 $f$，我们先算上单点的部分，然后 EGF 取 $\exp$ 转化为不要求联通的情况。简单图的数目是 $2^{\binom n2}$，于是 $f$ 容易求出。</p><p>问题来到二分图这边。考虑设染色二分图有 $h_n$ 个，显然</p><p>$$h_n=\sum_x\binom nx2^{x(n-x)}$$</p><p>注意到一个二分图的染色方案数是 $2^{\text{联通块数}}$ 的，于是</p><p>$$\exp(2(\hat g+z))=\hat h$$</p><p>从而</p><p>$$\hat g=\frac12\ln\hat h-z$$</p><p>最后问题转化为计算 $h$，这个考虑使用 Chirp-Z Transform，或者说也就是组合生成函数。</p><p>然后嗯做就好了。</p></details><h3 id=ur-19清扫银河>【UR #19】清扫银河
<a class=header-anchor href=#ur-19%e6%b8%85%e6%89%ab%e9%93%b6%e6%b2%b3></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>首先容易发现多个第二类操作可以直接叠加，所以第二类操作只会进行不超过 $1$ 次。</p><p>而对于多个第一类操作，我们也容易将其合并成 $\le m$ 次操作。</p><p>从而操作次数一定够用，我们只用考虑判断可行性。</p><p>考虑到第二种操作其实就是改变每个点的度数奇偶性，而我们可以用若干个对单个元素的操作来代表所有操作。</p><p>因此我们建出线性基，判断初始向量是否在线性基中即可。</p><p>使用 <code>bitset</code> 容易优化到 $O(n^3/w)$。</p></details><h3 id=ur-19通用测评号>【UR #19】通用测评号
<a class=header-anchor href=#ur-19%e9%80%9a%e7%94%a8%e6%b5%8b%e8%af%84%e5%8f%b7></a></h3><p><a href=https://www.cnblogs.com/myee/p/uoj514.html title=题解链接>题解链接
</a>。</p><h3 id=ur-19前进四>【UR #19】前进四
<a class=header-anchor href=#ur-19%e5%89%8d%e8%bf%9b%e5%9b%9b></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>容易想到小粉兔线段树，然而其是 $O(n+q\log^2n)$ 的。</p><p>考虑有没有什么别的做法。</p><p>考虑离线下来下标扫描线，那么就是区间取 $\min$，单点求被取 $\min$ 了几次。</p><p>使用吉司机线段树，复杂度 $O((n+q)\log n)$。</p></details><h3 id=美团杯2020测试赛子序列>【美团杯2020测试赛】子序列
<a class=header-anchor href=#%e7%be%8e%e5%9b%a2%e6%9d%af2020%e6%b5%8b%e8%af%95%e8%b5%9b%e5%ad%90%e5%ba%8f%e5%88%97></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>先考虑，如果最终字符串很短，那怎么做。</p><p>设 $f_p$ 表示以 $p$ 号位置为结尾的此前均未出现过的子序列有几个。</p><p>设 $q_p$ 为上一次 $p$ 对应字符出现位置，那么</p><p>$$f_p=\sum_{j=q_p}^{p-1}f_j$$</p><p>设</p><p>$$g_p=\sum_{j=0}^{p-1}f_j$$</p><p>则</p><p>$$g_{p+1}=g_p+f_p=2g_p-g_{q_p}$$</p><p>设 $h_{p,c}$ 表示 $p$ 之前的 $c$ 字符上次出现位置的 $g$ 值，不存在设为 $0$。</p><p>则即</p><p>$$g_{p+1}=2g_p-h_{p,c}$$</p><p>不妨考虑在状态里记录下</p><div>$$\begin{pmatrix}g_p\\h_{p,\texttt a}\\h_{p,\texttt b}\\\vdots\\h_{p,\texttt z}\end{pmatrix}$$</div><p>那么每在末尾加一个字符相当于左乘上一个矩阵。</p><p>注意到矩阵乘法有结合律，我们不妨考虑设字符 $c$ 对应矩阵为 $\textrm M_c$，则我们每次考虑字符 $s_n$，先左乘一次 $\textrm M_{s_n}$，再把所有字符对应的矩阵均左乘 $\textrm M_{s_n}$。</p><p>最后去掉空串的贡献即为答案。</p><p>这样单轮需要 $O(|\Sigma|^4)$ 的复杂度，进行 $O(n)$ 轮即为 $O(n|\Sigma|^4)$ 的。</p><p>由于占据空间很小，可以卡进缓存，访问又很连续，取模次数也可以优化，所以实际上很快。</p></details><h3 id=美团杯2020查查查乐乐>【美团杯2020】查查查乐乐
<a class=header-anchor href=#%e7%be%8e%e5%9b%a2%e6%9d%af2020%e6%9f%a5%e6%9f%a5%e6%9f%a5%e4%b9%90%e4%b9%90></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>设 $f_{n,k}$ 表示考虑了前 $n$ 个字符，而匹配了 $k$ 个查查查乐乐的最小代价。</p><p>每次在末尾加一个字符，尝试匹配一下即可。</p></details><h3 id=美团杯2020平行四边形>【美团杯2020】平行四边形
<a class=header-anchor href=#%e7%be%8e%e5%9b%a2%e6%9d%af2020%e5%b9%b3%e8%a1%8c%e5%9b%9b%e8%be%b9%e5%bd%a2></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>考虑找出 $n+1$ 的一个原根 $g$，则答案可以构造为 $(x,g^x\bmod(n+1))$。</p><p>合法性证明是容易的。</p></details><h3 id=美团杯2020114514>【美团杯2020】114514
<a class=header-anchor href=#%e7%be%8e%e5%9b%a2%e6%9d%af2020114514></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>先倒着把每个 <code>4</code> 和上一个未被用的 <code>1</code> 连在一起。</p><p>然后依次考虑每个 <code>14</code>，能和剩下的 <code>1</code> 配就配，否则和 <code>5</code> 配。</p><p>然后把 <code>114</code> 和 <code>514</code> 顺次连接即可。</p><p>易证这个贪心是正确的。</p></details><h3 id=unr-4序列妙妙值>【UNR #4】序列妙妙值
<a class=header-anchor href=#unr-4%e5%ba%8f%e5%88%97%e5%a6%99%e5%a6%99%e5%80%bc></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>考虑到，我们可以设 $f_{k,n}$ 表示把前 $n$ 个序列分成 $k$ 部分的最小代价。</p><p>则</p><p>$$f_{k,n}=\min_{j&lt;n}{f_{k-1,j}+\mathop\oplus\limits_{j&lt;i\le n}a_i}$$</p><p>其中 $\oplus$ 表示按位异或。</p><p>我们作前缀异或，设</p><p>$$v_n=v_{n-1}\oplus a_{n-1}$$</p><p>则</p><p>$$f_{k,n}=\min_{j&lt;n}{f_{k-1,j}+(v_j\oplus v_n)}$$</p><p>不妨考虑假设已知 $f_{k-1,k-1\sim n}$，现在要求 $f_{k,k\sim n}$。</p><p>则我们每次相当于动态往一个数据结构中插入一个键值对 $(a,b)$，然后给定 $v$ 查询数据结构中最小的 $a+(v\oplus b)$。</p><p>注意到值域很小（$&lt;2^{16}$），我们把值域二进制分成高八位和低八位。</p><p>设 $h_{A,B}$ 表示当前数据结构中 $(a,b)$ 满足 $b$ 的高八位为 $A$ 的最小的 $a+(B\oplus(b\bmod 256))$。</p><p>那么我们每次插入键值对时只用枚举 $B$ 的情况，而每次查询时只用枚举 $A$ 的情况，因此单次插入 / 查询是 $O(\sqrt v)$ 的。</p><p>由于要做 $k$ 轮，每轮 $O(n)$ 次操作，总复杂度即为 $O(nk\sqrt v)$，常数很小，容易通过。</p></details><h3 id=unr-4校园闲逛>【UNR #4】校园闲逛
<a class=header-anchor href=#unr-4%e6%a0%a1%e5%9b%ad%e9%97%b2%e9%80%9b></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>设 $f_{i,j,v}$ 表示 $i\rightarrow j$ 花费 $v$ 的方案数。</p><p>一种直接的想法是枚举最后一步走的边，按 $v$ 递增序更新。</p><p>这样的复杂度是 $O(nmv)$ 的。</p><p>这个看上去很扯淡，而且常数也不小。</p><p>不妨设 $g_{k,i,j,v}$ 表示从 $i$ 走到 $j$，走恰 $k$ 条边，花费为 $v$ 的方案数。</p><p>这样假设我们要求单个 $k$ 对应的所有 $g$，我们可以倍增 $\log k$ 轮，每轮进行 $O(n^2)$ 次长为 $O(v)$ 的 FFT，做到 $O((n^2v\log v+n^3v)\log k)$。</p><p>我们显然有</p><p>$$f_{i,j,v}=\sum_kg_{k,i,j,v}$$</p><p>我们不妨考虑在对 $g$ 倍增的同时，对 $g$ 关于 $k$ 的前缀和也倍增地计算贡献，从而可以统计 $f$ 的答案。</p><p>而我们知道，当 $k>v$ 时答案 $g$ 总为 $0$，因此我们只用统计 $0\le k\le v$ 的贡献即可。</p><p>这样我们就做到了 $O((n^2v\log v+n^3v)\log v)$ 的总复杂度。</p><hr><p>能不能再给力点啊？</p><p>考虑不从倍增入手，直接设</p><p>$$h_{i,j}=\sum_{e:i\rightarrow j}z^{v_e}$$</p><p>则</p><p>$$f_{i,j}=[i=j]+\sum_kf_{i,k}h_{k,j}$$</p><p>也即枚举最后一步选边。</p><p>改写成矩阵形式，</p><div>$$\begin{bmatrix}f_{1,1}&f_{1,2}&\cdots&f_{1,n}\\f_{2,1}&f_{2,2}&\cdots&f_{2,n}\\\vdots&\vdots&\ddots&\vdots\\f_{n,1}&f_{n,2}&\cdots&f_{n,n}\end{bmatrix}=I_n+\begin{bmatrix}f_{1,1}&f_{1,2}&\cdots&f_{1,n}\\f_{2,1}&f_{2,2}&\cdots&f_{2,n}\\\vdots&\vdots&\ddots&\vdots\\f_{n,1}&f_{n,2}&\cdots&f_{n,n}\end{bmatrix}\begin{bmatrix}h_{1,1}&h_{1,2}&\cdots&h_{1,n}\\h_{2,1}&h_{2,2}&\cdots&h_{2,n}\\\vdots&\vdots&\ddots&\vdots\\h_{n,1}&h_{n,2}&\cdots&h_{n,n}\end{bmatrix}$$</div><p>或者说</p><p>$$F=I+FH$$</p><p>改写一下</p><p>$$F=(I-H)^{-1}$$</p><p>即为矩阵求逆。</p><p>使用较好的实现即可做到 $O(n^2v\log v+n^3v)$。</p></details><h3 id=ulr-1多线程计算>【ULR #1】多线程计算
<a class=header-anchor href=#ulr-1%e5%a4%9a%e7%ba%bf%e7%a8%8b%e8%ae%a1%e7%ae%97></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>考虑当达到 $k$ 时有多少方案出现 $(x,y)$ 的状态；假设为 $f_{x,y,k}$，那么对答案的贡献即为 $[(x,y)\text{ is ok}]f_{x,y,k}F_k/(nm+1)\binom{nm}{k}$。</p><p>设在 $n\times m$ 的网格中填 $k$ 个位置使得各行各列均有元素的方案数为 $g_{n,m,k}$，那么我们有</p><p>$$f_{x,y,k}=\binom nx\binom myg_{n-x,m-y,nm-k}$$</p><p>理由是考虑翻转每个位置的状态。</p><p>而我们有</p><p>$$\sum_{i=0}^n\sum_{j=0}^m\binom ni\binom mjg_{i,j,k}=\binom{nm}k$$</p><p>从而</p><p>$$g_{n,m,k}=\sum_{i=0}^n\sum_{j=0}^m(-1)^{n+m-i-j}\binom ni\binom mj\binom{ij}k$$</p><p>于是答案即为</p><div>$$
\sum_{(x,y)\text{ is ok}}\binom nx\binom my\sum_k\frac{F_k}{(nm+1)\binom{nm}k}\sum_{i=0}^{n-x}\sum_{j=0}^{m-y}(-1)^{n+m-x-y-i-j}\binom{n-x}i\binom{m-y}j\binom{ij}{nm-k}
\\=\sum_{(x,y)\text{ is ok}}\binom nx\binom my\sum_{i=0}^{n-x}\sum_{j=0}^{m-y}(-1)^{n+m-x-y-i-j}\binom{n-x}i\binom{m-y}j\sum_k\frac{k!F_k(ij)^{\underline{nm-k}}}{(nm+1)!}
$$</div><p>设</p><p>$$S_v=\frac{v!}{(nm+1)!}\sum_k\frac{k!F_k}{(v+k-nm)!}$$</p><p>则答案即为</p><p>$$
\sum_{(x,y)\text{ is ok}}\binom nx\binom my\sum_{i=0}^{n-x}\sum_{j=0}^{m-y}(-1)^{n+m-x-y-i-j}\binom{n-x}i\binom{m-y}jS_{ij}
$$</p><p>设</p><p>$$h_{x,y}=\sum_{i=0}^x\sum_{j=0}^y(-1)^{x+y-i-j}\binom xi\binom yjS_{ij}$$</p><p>显然可以通过对 $2$ 维分别做一次卷积实现。</p><p>总复杂度 $O(nm\log(nm))$。</p></details><h3 id=ulr-1服务器调度>【ULR #1】服务器调度
<a class=header-anchor href=#ulr-1%e6%9c%8d%e5%8a%a1%e5%99%a8%e8%b0%83%e5%ba%a6></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>首先毫无疑问，我们对每种颜色维护其虚树直径，而答案就是与虚树上较远的距离有关。这个可以直接拿动态开点线段树来维护。对于 $\operatorname{lca}$ 的计算则需要 ST 表做到单次查询 $O(1)$。</p><p>然后先考虑直径是单点的情况。其给别的某个点带来距离的贡献。</p><p>$$\operatorname{dist}(u,v)=\operatorname{dep}(u)+\operatorname{dep}(v)-2\operatorname{dep}(\operatorname{lca}(u,v))$$</p><p>假设当前点是 $u$，则 $\operatorname{dep}(u)$ 容易打全局 tag，$\operatorname{dep}(v)$ 每个点恰好 $m$ 份。对于 $\operatorname{dep}(\operatorname{lca}(u,v))$，则考虑将其转化为</p><p>$$\sum_{p\text{ is ancestor of }v}[p\text{ is ancestor of }u]w_p$$</p><p>其中 $w_p$ 表示和父亲的距离。特别地，根节点为 $0$。</p><p>那我们给 $u$ 的所有祖先 $p$ 加上 $w_p$ 的贡献，那么如果询问是单点就直接链求和查询，使用带权的树剖线段树就做完了。</p><p>然而由于询问是子树，我们考虑对子树外的该部分贡献直接链查询，对子树内的该部分贡献每个点 $p$ 只会贡献 $\operatorname{size}(p)$ 次，使用带权的线段树直接计算即可。</p><p>然而直接可能是两个点，那我们同样分类讨论。</p><p>我们找到直径中点偏下面的那个点，令那个点子树内均以下面的点来计算贡献，否则以外面的点计算贡献，容斥一下也可以类似地拆贡献。</p><p>找直径中点的过程可以直接树剖二分，做到 $O(\log n)$。</p><p>使用树剖则总复杂度不会超过 $O((n+q)\log^2n)$，使用 GBT 即为 $O((n+q)\log n)$。</p></details><h3 id=新年的密码锁>新年的密码锁
<a class=header-anchor href=#%e6%96%b0%e5%b9%b4%e7%9a%84%e5%af%86%e7%a0%81%e9%94%81></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>玩一下可以发现，每次一定是形如把覆盖了一条边的所有路径删除。</p><p>考虑怎么选这条边：当其两侧都有路径时，其可被选择。</p><p>显然仅对 $\operatorname{lca}$ 往上的部分其下半边被选择了，否则即为上半边。</p><p>然后直接树剖再拿个随便什么 ds（譬如并查集）维护一下就可以快速找出每个位置什么时候开始合法。</p><p>最优解也同时拿个线段树维护一下就可以了。</p><p>总复杂度 $O(q\log n\log q+n\log q)$。</p></details><h3 id=unr-5提问系统>【UNR #5】提问系统
<a class=header-anchor href=#unr-5%e6%8f%90%e9%97%ae%e7%b3%bb%e7%bb%9f></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>容易发现形成树状结构，我们考虑树形 dp。</p><p>设子树 $p$ 内同时用了不超过 $x$ 个 R，同时用了不超过 $y$ 个 B，此时子树内的 $p_r^up_b^v$ 的总和为 $f_{p,x,y,u,v}$。</p><p>显然我们只用记录 $x+y\le siz_p,u\le1,v\le2$ 的方案。</p><p>合并两个子树的过程可以直接对小的子树扩容，然后直接对应位置二项式展开合并，做到 $O(\operatorname{size}(\text{大子树})^2)$。</p><p>我们按大小顺序依次合并，再插入根的信息，容易做到 $O(n^3)$。</p><p>这样是过不去的，考虑优化。</p><p>我们发现，由于每个节点选法只能是两种中的一种，因此 $c_b$ 的限制相当于变成了在每个叶子处有对链上 R 的下界的限制。</p><p>我们考虑记状态为当前节点到根为止恰有 $k$ 个 R 的情况下子树内各种方案的贡献和，那么容易发现 dp 非常容易转移。</p><p>这样的复杂度即为 $O(n^2)$，可以通过。</p></details><h3 id=unr-5获奖名单>【UNR #5】获奖名单
<a class=header-anchor href=#unr-5%e8%8e%b7%e5%a5%96%e5%90%8d%e5%8d%95></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>我们考虑一个节点为 $0\sim m$ 的图，$2$ 字符名字对应上面一条边，而单字符则对应和 $0$ 号点的连边。</p><p>我们考虑从 $0$ 号点开始跑欧拉回路，如果给出一组回路则给出了一组对称相消的方案。</p><p>当总长为偶数的时候，可能会出现一个孤立的自环，塞到中间即可。</p><p>当总长为奇数的时候，会无法正常跑欧拉回路，其中 $0$ 号点度数会是奇数，而另一个度数为奇数的节点则为中间点，直接跑欧拉路径即可。</p><p>此外还可能会有多余的孤立重边，往两侧塞即可。</p><p>总复杂度 $O(n+m)$，可以通过。</p><p>写的时候要注意一些诡异的边界问题。</p></details><h3 id=ur-22月球铁轨>【UR #22】月球铁轨
<a class=header-anchor href=#ur-22%e6%9c%88%e7%90%83%e9%93%81%e8%bd%a8></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>月球铁轨 = 星穹铁道（不是</p><p>容易想到改定义为强制选 $a$，而 $a\oplus b$ 可选是否并入答案。</p><p>那么一段区间的答案仅和区间内 $a$ 的异或和以及 $a\oplus b$ 张成的线性基有关。</p><p>考虑对区间左端点扫描线，那么右端点对应的本质不同线性基只有 $O(m)$ 个，其对应了若干区间。</p><p>每次插入一个元素时，我们在后面的线性基中总是会把最远一个可被代替的元素筛掉，也就对应着合并两个区间。</p><p>我们考虑对每个区间维护一个合法的 01Trie，支持子树按一定规则翻转（全部异或一个相同的数），子树内插入元素。</p><p>第一个操作直接打 tag 即可，第二个操作就是普通的 Trie 树插入。</p><p>当要往一个 Trie 对应的线性基更新的时候，我们直接暴力重构整个 Trie 即可；特别地，当要合并两个 Trie 的时候，前面一颗 Trie 的更新直接插入后面一颗 Trie 即可。</p><p>这样的复杂度可以证明不会超过 $O(nm^2)$。</p><p>考虑求第 $k$ 小的答案，我们把之前的所有 Trie 都可持久化下来，然后多树二分即可。</p><p>总复杂度 $O(nm^2)$。</p><p>代码：这谁写啊？</p></details><h3 id=ur-23地铁规划>【UR #23】地铁规划
<a class=header-anchor href=#ur-23%e5%9c%b0%e9%93%81%e8%a7%84%e5%88%92></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>蛮有趣的构造题，感觉挺好想的。</p><p>我们考虑到，这种结构看上去非常需要我们把一些边“暂存”到后面某个位置，使得之后弹出前面的边时不至于要弹出一大堆边。</p><p>我们考虑假设现在处理到 $l$，前 $c$ 条边被我们逆序插入，其余的边按照一定顺序穿插其中。</p><p>我们考虑对每个位置 $p&lt;m$ 设置一个父亲 $f_p>p$。</p><p>我们每次要弹出 $p$ 的时候，我们直接把到 $f_p-1$ 的边全部弹出，然后把到 $f_p-1$ 间-位置所有暂存的 $>c$ 的边插回栈中，再把 $p+1\sim f_p-1$ 逆序插回栈中。这个是 $f_p\le c$ 的情况。</p><p>当 $f_p>c$ 时，我们直接把当前栈弹空，然后将 $c$ 更新至当前的 $r$，并且把所有边逆序插入即可。</p><p>考虑怎么设置父亲。显然一种方法是直接翻转序列然后按照 BIT 的方法设置。容易证明这么做的操作次数级别为 $O(n\log n)$ 的，并且常数超级小，可以轻松通过。</p></details><h3 id=ur-23国王出游>【UR #23】国王出游
<a class=header-anchor href=#ur-23%e5%9b%bd%e7%8e%8b%e5%87%ba%e6%b8%b8></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>首先可以立刻写出答案：</p><p>$$\frac1{4^T}[\frac{x^n}{n!}\frac{y^m}{m!}](e^{Ax}+e^{-Bx} +e^{Cy}+e^{-Dy})^T$$</p><p>看上去没有什么比较好的性质，不妨设为求</p><p>$$[x^ny^m](f(x)+ g(y)+4)^T=\sum_{j\le n,k\le m}T^{\underline{j+k}}4^{T-j-k}\frac{[x^n]f(x)^j}{j!}\frac{[y^m]g(y)^k}{k!}$$</p><p>注意到这是一类可以套用拉反的
<a href=https://www.luogu.com.cn/blog/NaCly-Fish-blog/a-classical-problem title=经典形式>经典形式
</a>。</p><p>由于 $f(x)=e^{Ax}+e^{-Bx}-2$，我们现在假设 $f^{(-1)}$ 为其复合逆，则另类拉格朗日反演给出</p><p>$$w_j=[x^n]f(x)^j=[x^{n-j}] (f^{(-1)})&rsquo;(x/f^{(-1)})^{n+1}$$</p><p>我们现在要求 $h=f^{(-1)}$，可以直接上牛顿迭代：</p><p>$$h\leftarrow h-\frac{\exp(Ah)+\exp(-Bh)-2}{A\exp(Ah)-B\exp(-Bh)}$$</p><p>但是刚刚的方法要求复合逆存在，而 $A=B$ 时复合逆显然不存在（$[x^1]f=0$），此时我们有</p><p>$$[x^n] (e^{Ax}+e^{-Ax}-2)^j=(A/2)^n[x^n] (e^x-e^{-x})^{2j}$$</p><p>对 $e^x-e^{-x}$ 套用同样做法即可即可。</p><p>同样方法算出 $[y^m]g(y)^j$，最后计算答案显然就是一次卷积。</p><p>总复杂度 $O((n+m)\log(n+m)+\log v)$，但是由于牛顿迭代常数巨大（如果不同步进行并加卡常的话），实际跑起来估计并不快。</p><p>代码咕了。都 3202 年了，还有谁往 CTT 投不下发板子的多项式啊？</p></details><h3 id=tba>TBA
<a class=header-anchor href=#tba></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary></details><h3 id=tba-1>TBA
<a class=header-anchor href=#tba-1></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary></details><h3 id=tba-2>TBA
<a class=header-anchor href=#tba-2></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary></details><h3 id=tba-3>TBA
<a class=header-anchor href=#tba-3></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary></details><h3 id=tba-4>TBA
<a class=header-anchor href=#tba-4></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary></details><h3 id=tba-5>TBA
<a class=header-anchor href=#tba-5></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary></details><h3 id=tba-6>TBA
<a class=header-anchor href=#tba-6></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary></details><h3 id=tba-7>TBA
<a class=header-anchor href=#tba-7></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary></details><h3 id=tba-8>TBA
<a class=header-anchor href=#tba-8></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary></details><h3 id=tba-9>TBA
<a class=header-anchor href=#tba-9></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary></details><h3 id=tba-10>TBA
<a class=header-anchor href=#tba-10></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary></details><h3 id=unr-6笔试>【UNR #6】笔试
<a class=header-anchor href=#unr-6%e7%ac%94%e8%af%95></a></h3><details class="custom-block details" style="display:block;position:relative;border-radius:2px;margin:1.6em 0;padding:1.6em;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,Oxygen,Ubuntu,Cantarell,fira sans,droid sans,helvetica neue,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0;text-transform:none;white-space:normal;widows:2;word-spacing:0;-webkit-text-stroke-width:0;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial"><summary style=outline:none;cursor:pointer>题解</summary><p>练这套题前先刷了一中午
<a href=https://duck.ac/beibishi title=https://duck.ac/beibishi>https://duck.ac/beibishi
</a>。</p><p>怎么笔试第一题还 AB 看反了的。/fn</p><p>答案：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-1> 1</a></span><span>A
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-2><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-2> 2</a></span><span>B
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-3><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-3> 3</a></span><span>B
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-4><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-4> 4</a></span><span>D
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-5><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-5> 5</a></span><span>C
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-6><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-6> 6</a></span><span>A
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-7><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-7> 7</a></span><span>D
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-8><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-8> 8</a></span><span>C
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-9><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-9> 9</a></span><span>C
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-10><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-10>10</a></span><span>A
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-11><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-11>11</a></span><span>C
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-12><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-12>12</a></span><span>C
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-13><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-13>13</a></span><span>C
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-14><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-14>14</a></span><span>D
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-15><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-15>15</a></span><span>D
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-16><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-16>16</a></span><span>A
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-17><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-17>17</a></span><span>B
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-18><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-18>18</a></span><span>C
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-19><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-19>19</a></span><span>D
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-20><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-20>20</a></span><span>A
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-21><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-21>21</a></span><span>D
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-22><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-22>22</a></span><span>A
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-23><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-23>23</a></span><span>B
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-24><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-24>24</a></span><span>A
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-25><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-25>25</a></span><span>D
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-26><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-26>26</a></span><span>A
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-27><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-27>27</a></span><span>D
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-28><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-28>28</a></span><span>B
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-29><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-29>29</a></span><span>C
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-30><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-30>30</a></span><span>D
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-31><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-31>31</a></span><span>C
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-32><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-32>32</a></span><span>B
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-33><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-33>33</a></span><span>B
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-34><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-34>34</a></span><span>B
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-35><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-35>35</a></span><span>B
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-36><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-36>36</a></span><span>B
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-37><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-37>37</a></span><span>A
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-38><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-38>38</a></span><span>D
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-39><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-39>39</a></span><span>A
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-40><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-40>40</a></span><span>A
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-41><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-41>41</a></span><span>D
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-42><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-42>42</a></span><span>C
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-43><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-43>43</a></span><span>D
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-44><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-44>44</a></span><span>A
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-45><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-45>45</a></span><span>B
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-46><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-46>46</a></span><span>BDF
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-47><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-47>47</a></span><span>ABF
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-48><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-48>48</a></span><span>AF
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-49><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-49>49</a></span><span>EFG
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-50><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-50>50</a></span><span>AD
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f" id=hl-7-51><a style=outline:none;text-decoration:none;color:inherit href=#hl-7-51>51</a></span><span>A
</span></span></code></pre></div></details></div><footer class=post-footer><div class=post-tags><a href=/tags/%e9%a2%98%e8%a7%a3>题解</a>
<a href=/tags/%e5%81%9a%e9%a2%98%e8%ae%b0%e5%bd%95>做题记录</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
UOJ随做</li><li class=post-copyright-author><strong>本文作者：</strong>
myee</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://myeeye.github.io/post/uoj-record/ title=UOJ随做>https://myeeye.github.io/post/uoj-record/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/uoj56/ rel=next title=uoj56><i class="fa fa-chevron-left"></i> uoj56</a></div><div class="post-nav-prev post-nav-item"><a href=/post/3-smooth-number/ rel=prev title="3-smooth 数相关">3-smooth 数相关
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2025</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>myee</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.118.2 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动，做出了一定的改动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#e0e1cc","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Announcements","categoryid":"DIC_kwDOKQa_as4CZVPp","emit":false,"inputposition":"top","mapping":"pathname","reactions":false,"repo":"myeeye/myeeye.github.io","repoid":"R_kgDOKQa_ag","theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://myeeye.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"manual","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":true,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.5.3"}</script><script type=text/javascript src=/js/main.min.2ae7a62913f814cac7b37958c1b62b1bc85d987f4c81e6cccffd5293f012ed2c.js defer></script></body></html>